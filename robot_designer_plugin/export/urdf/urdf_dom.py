#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed Jun 24 08:52:21 2015 by generateDS.py version 2.14a.
#
# Command line options:
#   ('--external-encoding', 'utf-8')
#   ('-f', '')
#   ('-o', 'urdf_dom.py')
#
# Command line arguments:
#   ../share/urdf.xsd
#
# Command line:
#   /usr/local/bin/generateDS.py --external-encoding="utf-8" -f -o "urdf_dom.py" ../share/urdf.xsd
#
# Current working directory (os.getcwd()):
#   generated
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_


Validate_simpletypes_ = True


etree_ = None
Verbose_import_ = False
(
    XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
) = list(range(3))
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")


def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
            'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, str) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, str) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class pose(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, rpy='0 0 0', xyz='0 0 0'):
        self.original_tagname_ = None
        self.rpy = _cast(None, rpy)
        self.xyz = _cast(None, xyz)
    def factory(*args_, **kwargs_):
        if pose.subclass:
            return pose.subclass(*args_, **kwargs_)
        else:
            return pose(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rpy(self): return self.rpy
    def set_rpy(self, rpy): self.rpy = rpy
    def get_xyz(self): return self.xyz
    def set_xyz(self, xyz): self.xyz = xyz
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='pose', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pose')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='pose', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='pose'):
        if self.rpy is not None and 'rpy' not in already_processed:
            already_processed.add('rpy')
            outfile.write(' rpy=%s' % (self.gds_format_string(quote_attrib(self.rpy), input_name='rpy'), ))
        if self.xyz is not None and 'xyz' not in already_processed:
            already_processed.add('xyz')
            outfile.write(' xyz=%s' % (self.gds_format_string(quote_attrib(self.xyz), input_name='xyz'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='pose', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='pose'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.rpy is not None and 'rpy' not in already_processed:
            already_processed.add('rpy')
            showIndent(outfile, level)
            outfile.write('rpy="%s",\n' % (self.rpy,))
        if self.xyz is not None and 'xyz' not in already_processed:
            already_processed.add('xyz')
            showIndent(outfile, level)
            outfile.write('xyz="%s",\n' % (self.xyz,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rpy', node)
        if value is not None and 'rpy' not in already_processed:
            already_processed.add('rpy')
            self.rpy = value
        value = find_attr_value_('xyz', node)
        if value is not None and 'xyz' not in already_processed:
            already_processed.add('xyz')
            self.xyz = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class pose


class color(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, rgba='0 0 0 0'):
        self.original_tagname_ = None
        self.rgba = _cast(None, rgba)
    def factory(*args_, **kwargs_):
        if color.subclass:
            return color.subclass(*args_, **kwargs_)
        else:
            return color(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rgba(self): return self.rgba
    def set_rgba(self, rgba): self.rgba = rgba
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='color', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='color')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='color', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='color'):
        if self.rgba is not None and 'rgba' not in already_processed:
            already_processed.add('rgba')
            outfile.write(' rgba=%s' % (self.gds_format_string(quote_attrib(self.rgba), input_name='rgba'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='color', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='color'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.rgba is not None and 'rgba' not in already_processed:
            already_processed.add('rgba')
            showIndent(outfile, level)
            outfile.write('rgba="%s",\n' % (self.rgba,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rgba', node)
        if value is not None and 'rgba' not in already_processed:
            already_processed.add('rgba')
            self.rgba = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class color


class verbose(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None):
        self.original_tagname_ = None
        self.value = _cast(None, value)
    def factory(*args_, **kwargs_):
        if verbose.subclass:
            return verbose.subclass(*args_, **kwargs_)
        else:
            return verbose(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='verbose', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='verbose')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='verbose', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='verbose'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='verbose', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='verbose'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class verbose


class name(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
    def factory(*args_, **kwargs_):
        if name.subclass:
            return name.subclass(*args_, **kwargs_)
        else:
            return name(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='name', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='name')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='name', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='name'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='name', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='name'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class name


class mass(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=0):
        self.original_tagname_ = None
        self.value = _cast(float, value)
    def factory(*args_, **kwargs_):
        if mass.subclass:
            return mass.subclass(*args_, **kwargs_)
        else:
            return mass(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='mass', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mass')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='mass', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='mass'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_double(self.value, input_name='value'))
    def exportChildren(self, outfile, level, namespace_='', name_='mass', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='mass'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value=%e,\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            try:
                self.value = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class mass


class inertia(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ixz=0, ixx=0, ixy=0, izz=0, iyy=0, iyz=0):
        self.original_tagname_ = None
        self.ixz = _cast(float, ixz)
        self.ixx = _cast(float, ixx)
        self.ixy = _cast(float, ixy)
        self.izz = _cast(float, izz)
        self.iyy = _cast(float, iyy)
        self.iyz = _cast(float, iyz)
    def factory(*args_, **kwargs_):
        if inertia.subclass:
            return inertia.subclass(*args_, **kwargs_)
        else:
            return inertia(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ixz(self): return self.ixz
    def set_ixz(self, ixz): self.ixz = ixz
    def get_ixx(self): return self.ixx
    def set_ixx(self, ixx): self.ixx = ixx
    def get_ixy(self): return self.ixy
    def set_ixy(self, ixy): self.ixy = ixy
    def get_izz(self): return self.izz
    def set_izz(self, izz): self.izz = izz
    def get_iyy(self): return self.iyy
    def set_iyy(self, iyy): self.iyy = iyy
    def get_iyz(self): return self.iyz
    def set_iyz(self, iyz): self.iyz = iyz
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='inertia', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='inertia')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='inertia', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='inertia'):
        if self.ixz is not None and 'ixz' not in already_processed:
            already_processed.add('ixz')
            outfile.write(' ixz="%s"' % self.gds_format_double(self.ixz, input_name='ixz'))
        if self.ixx is not None and 'ixx' not in already_processed:
            already_processed.add('ixx')
            outfile.write(' ixx="%s"' % self.gds_format_double(self.ixx, input_name='ixx'))
        if self.ixy is not None and 'ixy' not in already_processed:
            already_processed.add('ixy')
            outfile.write(' ixy="%s"' % self.gds_format_double(self.ixy, input_name='ixy'))
        if self.izz is not None and 'izz' not in already_processed:
            already_processed.add('izz')
            outfile.write(' izz="%s"' % self.gds_format_double(self.izz, input_name='izz'))
        if self.iyy is not None and 'iyy' not in already_processed:
            already_processed.add('iyy')
            outfile.write(' iyy="%s"' % self.gds_format_double(self.iyy, input_name='iyy'))
        if self.iyz is not None and 'iyz' not in already_processed:
            already_processed.add('iyz')
            outfile.write(' iyz="%s"' % self.gds_format_double(self.iyz, input_name='iyz'))
    def exportChildren(self, outfile, level, namespace_='', name_='inertia', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='inertia'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ixz is not None and 'ixz' not in already_processed:
            already_processed.add('ixz')
            showIndent(outfile, level)
            outfile.write('ixz=%e,\n' % (self.ixz,))
        if self.ixx is not None and 'ixx' not in already_processed:
            already_processed.add('ixx')
            showIndent(outfile, level)
            outfile.write('ixx=%e,\n' % (self.ixx,))
        if self.ixy is not None and 'ixy' not in already_processed:
            already_processed.add('ixy')
            showIndent(outfile, level)
            outfile.write('ixy=%e,\n' % (self.ixy,))
        if self.izz is not None and 'izz' not in already_processed:
            already_processed.add('izz')
            showIndent(outfile, level)
            outfile.write('izz=%e,\n' % (self.izz,))
        if self.iyy is not None and 'iyy' not in already_processed:
            already_processed.add('iyy')
            showIndent(outfile, level)
            outfile.write('iyy=%e,\n' % (self.iyy,))
        if self.iyz is not None and 'iyz' not in already_processed:
            already_processed.add('iyz')
            showIndent(outfile, level)
            outfile.write('iyz=%e,\n' % (self.iyz,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ixz', node)
        if value is not None and 'ixz' not in already_processed:
            already_processed.add('ixz')
            try:
                self.ixz = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (ixz): %s' % exp)
        value = find_attr_value_('ixx', node)
        if value is not None and 'ixx' not in already_processed:
            already_processed.add('ixx')
            try:
                self.ixx = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (ixx): %s' % exp)
        value = find_attr_value_('ixy', node)
        if value is not None and 'ixy' not in already_processed:
            already_processed.add('ixy')
            try:
                self.ixy = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (ixy): %s' % exp)
        value = find_attr_value_('izz', node)
        if value is not None and 'izz' not in already_processed:
            already_processed.add('izz')
            try:
                self.izz = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (izz): %s' % exp)
        value = find_attr_value_('iyy', node)
        if value is not None and 'iyy' not in already_processed:
            already_processed.add('iyy')
            try:
                self.iyy = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (iyy): %s' % exp)
        value = find_attr_value_('iyz', node)
        if value is not None and 'iyz' not in already_processed:
            already_processed.add('iyz')
            try:
                self.iyz = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (iyz): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class inertia


class inertial(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, origin=None, mass=None, inertia=None):
        self.original_tagname_ = None
        self.origin = origin
        self.mass = mass
        self.inertia = inertia
    def factory(*args_, **kwargs_):
        if inertial.subclass:
            return inertial.subclass(*args_, **kwargs_)
        else:
            return inertial(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_origin(self): return self.origin
    def set_origin(self, origin): self.origin = origin
    def get_mass(self): return self.mass
    def set_mass(self, mass): self.mass = mass
    def get_inertia(self): return self.inertia
    def set_inertia(self, inertia): self.inertia = inertia
    def hasContent_(self):
        if (
            self.origin is not None or
            self.mass is not None or
            self.inertia is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='inertial', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='inertial')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='inertial', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='inertial'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='inertial', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.origin is not None:
            self.origin.export(outfile, level, namespace_, name_='origin', pretty_print=pretty_print)
        if self.mass is not None:
            self.mass.export(outfile, level, namespace_, name_='mass', pretty_print=pretty_print)
        if self.inertia is not None:
            self.inertia.export(outfile, level, namespace_, name_='inertia', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='inertial'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.origin is not None:
            showIndent(outfile, level)
            outfile.write('origin=model_.pose(\n')
            self.origin.exportLiteral(outfile, level, name_='origin')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.mass is not None:
            showIndent(outfile, level)
            outfile.write('mass=model_.mass(\n')
            self.mass.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.inertia is not None:
            showIndent(outfile, level)
            outfile.write('inertia=model_.inertia(\n')
            self.inertia.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'origin':
            obj_ = pose.factory()
            obj_.build(child_)
            self.origin = obj_
            obj_.original_tagname_ = 'origin'
        elif nodeName_ == 'mass':
            obj_ = mass.factory()
            obj_.build(child_)
            self.mass = obj_
            obj_.original_tagname_ = 'mass'
        elif nodeName_ == 'inertia':
            obj_ = inertia.factory()
            obj_.build(child_)
            self.inertia = obj_
            obj_.original_tagname_ = 'inertia'
# end class inertial


class box(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, size='0 0 0'):
        self.original_tagname_ = None
        self.size = _cast(None, size)
    def factory(*args_, **kwargs_):
        if box.subclass:
            return box.subclass(*args_, **kwargs_)
        else:
            return box(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='box', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='box')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='box', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='box'):
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size=%s' % (self.gds_format_string(quote_attrib(self.size), input_name='size'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='box', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='box'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            showIndent(outfile, level)
            outfile.write('size="%s",\n' % (self.size,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            self.size = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class box


class cylinder(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, length=None, radius=None):
        self.original_tagname_ = None
        self.length = _cast(float, length)
        self.radius = _cast(float, radius)
    def factory(*args_, **kwargs_):
        if cylinder.subclass:
            return cylinder.subclass(*args_, **kwargs_)
        else:
            return cylinder(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_length(self): return self.length
    def set_length(self, length): self.length = length
    def get_radius(self): return self.radius
    def set_radius(self, radius): self.radius = radius
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cylinder', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cylinder')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cylinder', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cylinder'):
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length="%s"' % self.gds_format_double(self.length, input_name='length'))
        if self.radius is not None and 'radius' not in already_processed:
            already_processed.add('radius')
            outfile.write(' radius="%s"' % self.gds_format_double(self.radius, input_name='radius'))
    def exportChildren(self, outfile, level, namespace_='', name_='cylinder', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cylinder'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            showIndent(outfile, level)
            outfile.write('length=%e,\n' % (self.length,))
        if self.radius is not None and 'radius' not in already_processed:
            already_processed.add('radius')
            showIndent(outfile, level)
            outfile.write('radius=%e,\n' % (self.radius,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            try:
                self.length = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (length): %s' % exp)
        value = find_attr_value_('radius', node)
        if value is not None and 'radius' not in already_processed:
            already_processed.add('radius')
            try:
                self.radius = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (radius): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cylinder


class sphere(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, radius=None):
        self.original_tagname_ = None
        self.radius = _cast(float, radius)
    def factory(*args_, **kwargs_):
        if sphere.subclass:
            return sphere.subclass(*args_, **kwargs_)
        else:
            return sphere(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_radius(self): return self.radius
    def set_radius(self, radius): self.radius = radius
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='sphere', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sphere')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='sphere', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='sphere'):
        if self.radius is not None and 'radius' not in already_processed:
            already_processed.add('radius')
            outfile.write(' radius="%s"' % self.gds_format_double(self.radius, input_name='radius'))
    def exportChildren(self, outfile, level, namespace_='', name_='sphere', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='sphere'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.radius is not None and 'radius' not in already_processed:
            already_processed.add('radius')
            showIndent(outfile, level)
            outfile.write('radius=%e,\n' % (self.radius,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('radius', node)
        if value is not None and 'radius' not in already_processed:
            already_processed.add('radius')
            try:
                self.radius = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (radius): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class sphere


class mesh(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, scale='1 1 1', filename=None):
        self.original_tagname_ = None
        self.scale = _cast(None, scale)
        self.filename = _cast(None, filename)
    def factory(*args_, **kwargs_):
        if mesh.subclass:
            return mesh.subclass(*args_, **kwargs_)
        else:
            return mesh(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_scale(self): return self.scale
    def set_scale(self, scale): self.scale = scale
    def get_filename(self): return self.filename
    def set_filename(self, filename): self.filename = filename
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='mesh', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mesh')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='mesh', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='mesh'):
        if self.scale is not None and 'scale' not in already_processed:
            already_processed.add('scale')
            outfile.write(' scale=%s' % (self.gds_format_string(quote_attrib(self.scale), input_name='scale'), ))
        if self.filename is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            outfile.write(' filename=%s' % (self.gds_format_string(quote_attrib(self.filename), input_name='filename'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='mesh', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='mesh'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.scale is not None and 'scale' not in already_processed:
            already_processed.add('scale')
            showIndent(outfile, level)
            outfile.write('scale="%s",\n' % (self.scale,))
        if self.filename is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            showIndent(outfile, level)
            outfile.write('filename="%s",\n' % (self.filename,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('scale', node)
        if value is not None and 'scale' not in already_processed:
            already_processed.add('scale')
            self.scale = value
        value = find_attr_value_('filename', node)
        if value is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            self.filename = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class mesh


class geometry(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, box=None, cylinder=None, sphere=None, mesh=None):
        self.original_tagname_ = None
        self.box = box
        self.cylinder = cylinder
        self.sphere = sphere
        self.mesh = mesh
    def factory(*args_, **kwargs_):
        if geometry.subclass:
            return geometry.subclass(*args_, **kwargs_)
        else:
            return geometry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_box(self): return self.box
    def set_box(self, box): self.box = box
    def get_cylinder(self): return self.cylinder
    def set_cylinder(self, cylinder): self.cylinder = cylinder
    def get_sphere(self): return self.sphere
    def set_sphere(self, sphere): self.sphere = sphere
    def get_mesh(self): return self.mesh
    def set_mesh(self, mesh): self.mesh = mesh
    def hasContent_(self):
        if (
            self.box is not None or
            self.cylinder is not None or
            self.sphere is not None or
            self.mesh is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='geometry', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='geometry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='geometry', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='geometry'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='geometry', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.box is not None:
            self.box.export(outfile, level, namespace_, name_='box', pretty_print=pretty_print)
        if self.cylinder is not None:
            self.cylinder.export(outfile, level, namespace_, name_='cylinder', pretty_print=pretty_print)
        if self.sphere is not None:
            self.sphere.export(outfile, level, namespace_, name_='sphere', pretty_print=pretty_print)
        if self.mesh is not None:
            self.mesh.export(outfile, level, namespace_, name_='mesh', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='geometry'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.box is not None:
            showIndent(outfile, level)
            outfile.write('box=model_.box(\n')
            self.box.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cylinder is not None:
            showIndent(outfile, level)
            outfile.write('cylinder=model_.cylinder(\n')
            self.cylinder.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sphere is not None:
            showIndent(outfile, level)
            outfile.write('sphere=model_.sphere(\n')
            self.sphere.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.mesh is not None:
            showIndent(outfile, level)
            outfile.write('mesh=model_.mesh(\n')
            self.mesh.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'box':
            obj_ = box.factory()
            obj_.build(child_)
            self.box = obj_
            obj_.original_tagname_ = 'box'
        elif nodeName_ == 'cylinder':
            obj_ = cylinder.factory()
            obj_.build(child_)
            self.cylinder = obj_
            obj_.original_tagname_ = 'cylinder'
        elif nodeName_ == 'sphere':
            obj_ = sphere.factory()
            obj_.build(child_)
            self.sphere = obj_
            obj_.original_tagname_ = 'sphere'
        elif nodeName_ == 'mesh':
            obj_ = mesh.factory()
            obj_.build(child_)
            self.mesh = obj_
            obj_.original_tagname_ = 'mesh'
# end class geometry


class texture(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, filename=None):
        self.original_tagname_ = None
        self.filename = _cast(None, filename)
    def factory(*args_, **kwargs_):
        if texture.subclass:
            return texture.subclass(*args_, **kwargs_)
        else:
            return texture(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_filename(self): return self.filename
    def set_filename(self, filename): self.filename = filename
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='texture', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='texture')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='texture', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='texture'):
        if self.filename is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            outfile.write(' filename=%s' % (self.gds_format_string(quote_attrib(self.filename), input_name='filename'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='texture', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='texture'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.filename is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            showIndent(outfile, level)
            outfile.write('filename="%s",\n' % (self.filename,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('filename', node)
        if value is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            self.filename = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class texture


class material(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, color=None, texture=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.color = color
        self.texture = texture
    def factory(*args_, **kwargs_):
        if material.subclass:
            return material.subclass(*args_, **kwargs_)
        else:
            return material(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_color(self): return self.color
    def set_color(self, color): self.color = color
    def get_texture(self): return self.texture
    def set_texture(self, texture): self.texture = texture
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            self.color is not None or
            self.texture is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='material', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='material')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='material', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='material'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='material', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.color is not None:
            self.color.export(outfile, level, namespace_, name_='color', pretty_print=pretty_print)
        if self.texture is not None:
            self.texture.export(outfile, level, namespace_, name_='texture', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='material'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.color is not None:
            showIndent(outfile, level)
            outfile.write('color=model_.color(\n')
            self.color.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.texture is not None:
            showIndent(outfile, level)
            outfile.write('texture=model_.texture(\n')
            self.texture.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'color':
            obj_ = color.factory()
            obj_.build(child_)
            self.color = obj_
            obj_.original_tagname_ = 'color'
        elif nodeName_ == 'texture':
            obj_ = texture.factory()
            obj_.build(child_)
            self.texture = obj_
            obj_.original_tagname_ = 'texture'
# end class material


class material_global(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, color=None, texture=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.color = color
        self.texture = texture
    def factory(*args_, **kwargs_):
        if material_global.subclass:
            return material_global.subclass(*args_, **kwargs_)
        else:
            return material_global(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_color(self): return self.color
    def set_color(self, color): self.color = color
    def get_texture(self): return self.texture
    def set_texture(self, texture): self.texture = texture
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            self.color is not None or
            self.texture is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='material_global', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='material_global')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='material_global', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='material_global'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='material_global', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.color is not None:
            self.color.export(outfile, level, namespace_, name_='color', pretty_print=pretty_print)
        if self.texture is not None:
            self.texture.export(outfile, level, namespace_, name_='texture', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='material_global'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.color is not None:
            showIndent(outfile, level)
            outfile.write('color=model_.color(\n')
            self.color.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.texture is not None:
            showIndent(outfile, level)
            outfile.write('texture=model_.texture(\n')
            self.texture.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'color':
            obj_ = color.factory()
            obj_.build(child_)
            self.color = obj_
            obj_.original_tagname_ = 'color'
        elif nodeName_ == 'texture':
            obj_ = texture.factory()
            obj_.build(child_)
            self.texture = obj_
            obj_.original_tagname_ = 'texture'
# end class material_global


class visual(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, origin=None, geometry=None, material=None):
        self.original_tagname_ = None
        self.origin = origin
        self.geometry = geometry
        self.material = material
    def factory(*args_, **kwargs_):
        if visual.subclass:
            return visual.subclass(*args_, **kwargs_)
        else:
            return visual(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_origin(self): return self.origin
    def set_origin(self, origin): self.origin = origin
    def get_geometry(self): return self.geometry
    def set_geometry(self, geometry): self.geometry = geometry
    def get_material(self): return self.material
    def set_material(self, material): self.material = material
    def hasContent_(self):
        if (
            self.origin is not None or
            self.geometry is not None or
            self.material is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='visual', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='visual')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='visual', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='visual'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='visual', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.origin is not None:
            self.origin.export(outfile, level, namespace_, name_='origin', pretty_print=pretty_print)
        if self.geometry is not None:
            self.geometry.export(outfile, level, namespace_, name_='geometry', pretty_print=pretty_print)
        if self.material is not None:
            self.material.export(outfile, level, namespace_, name_='material', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='visual'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.origin is not None:
            showIndent(outfile, level)
            outfile.write('origin=model_.pose(\n')
            self.origin.exportLiteral(outfile, level, name_='origin')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.geometry is not None:
            showIndent(outfile, level)
            outfile.write('geometry=model_.geometry(\n')
            self.geometry.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.material is not None:
            showIndent(outfile, level)
            outfile.write('material=model_.material(\n')
            self.material.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'origin':
            obj_ = pose.factory()
            obj_.build(child_)
            self.origin = obj_
            obj_.original_tagname_ = 'origin'
        elif nodeName_ == 'geometry':
            obj_ = geometry.factory()
            obj_.build(child_)
            self.geometry = obj_
            obj_.original_tagname_ = 'geometry'
        elif nodeName_ == 'material':
            obj_ = material.factory()
            obj_.build(child_)
            self.material = obj_
            obj_.original_tagname_ = 'material'
# end class visual


class collision(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, origin=None, geometry=None, verbose=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.origin = origin
        self.geometry = geometry
        self.verbose = verbose
    def factory(*args_, **kwargs_):
        if collision.subclass:
            return collision.subclass(*args_, **kwargs_)
        else:
            return collision(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_origin(self): return self.origin
    def set_origin(self, origin): self.origin = origin
    def get_geometry(self): return self.geometry
    def set_geometry(self, geometry): self.geometry = geometry
    def get_verbose(self): return self.verbose
    def set_verbose(self, verbose): self.verbose = verbose
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            self.origin is not None or
            self.geometry is not None or
            self.verbose is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='collision', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='collision')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='collision', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='collision'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='collision', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.origin is not None:
            self.origin.export(outfile, level, namespace_, name_='origin', pretty_print=pretty_print)
        if self.geometry is not None:
            self.geometry.export(outfile, level, namespace_, name_='geometry', pretty_print=pretty_print)
        if self.verbose is not None:
            self.verbose.export(outfile, level, namespace_, name_='verbose', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='collision'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.origin is not None:
            showIndent(outfile, level)
            outfile.write('origin=model_.pose(\n')
            self.origin.exportLiteral(outfile, level, name_='origin')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.geometry is not None:
            showIndent(outfile, level)
            outfile.write('geometry=model_.geometry(\n')
            self.geometry.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.verbose is not None:
            showIndent(outfile, level)
            outfile.write('verbose=model_.verbose(\n')
            self.verbose.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'origin':
            obj_ = pose.factory()
            obj_.build(child_)
            self.origin = obj_
            obj_.original_tagname_ = 'origin'
        elif nodeName_ == 'geometry':
            obj_ = geometry.factory()
            obj_.build(child_)
            self.geometry = obj_
            obj_.original_tagname_ = 'geometry'
        elif nodeName_ == 'verbose':
            obj_ = verbose.factory()
            obj_.build(child_)
            self.verbose = obj_
            obj_.original_tagname_ = 'verbose'
# end class collision


class link(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, name=None, inertial=None, visual=None, collision=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.name = _cast(None, name)
        self.inertial = inertial
        if visual is None:
            self.visual = []
        else:
            self.visual = visual
        if collision is None:
            self.collision = []
        else:
            self.collision = collision
    def factory(*args_, **kwargs_):
        if link.subclass:
            return link.subclass(*args_, **kwargs_)
        else:
            return link(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_inertial(self): return self.inertial
    def set_inertial(self, inertial): self.inertial = inertial
    def get_visual(self): return self.visual
    def set_visual(self, visual): self.visual = visual
    def add_visual(self, value): self.visual.append(value)
    def insert_visual_at(self, index, value): self.visual.insert(index, value)
    def replace_visual_at(self, index, value): self.visual[index] = value
    def get_collision(self): return self.collision
    def set_collision(self, collision): self.collision = collision
    def add_collision(self, value): self.collision.append(value)
    def insert_collision_at(self, index, value): self.collision.insert(index, value)
    def replace_collision_at(self, index, value): self.collision[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            self.inertial is not None or
            self.visual or
            self.collision
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='link', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='link')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='link', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='link'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_), input_name='type'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='link', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.inertial is not None:
            self.inertial.export(outfile, level, namespace_, name_='inertial', pretty_print=pretty_print)
        for visual_ in self.visual:
            visual_.export(outfile, level, namespace_, name_='visual', pretty_print=pretty_print)
        for collision_ in self.collision:
            collision_.export(outfile, level, namespace_, name_='collision', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='link'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.inertial is not None:
            showIndent(outfile, level)
            outfile.write('inertial=model_.inertial(\n')
            self.inertial.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('visual=[\n')
        level += 1
        for visual_ in self.visual:
            showIndent(outfile, level)
            outfile.write('model_.visual(\n')
            visual_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('collision=[\n')
        level += 1
        for collision_ in self.collision:
            showIndent(outfile, level)
            outfile.write('model_.collision(\n')
            collision_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'inertial':
            obj_ = inertial.factory()
            obj_.build(child_)
            self.inertial = obj_
            obj_.original_tagname_ = 'inertial'
        elif nodeName_ == 'visual':
            obj_ = visual.factory()
            obj_.build(child_)
            self.visual.append(obj_)
            obj_.original_tagname_ = 'visual'
        elif nodeName_ == 'collision':
            obj_ = collision.factory()
            obj_.build(child_)
            self.collision.append(obj_)
            obj_.original_tagname_ = 'collision'
# end class link


class parent(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, link=None):
        self.original_tagname_ = None
        self.link = _cast(None, link)
    def factory(*args_, **kwargs_):
        if parent.subclass:
            return parent.subclass(*args_, **kwargs_)
        else:
            return parent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_link(self): return self.link
    def set_link(self, link): self.link = link
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='parent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='parent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='parent', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='parent'):
        if self.link is not None and 'link' not in already_processed:
            already_processed.add('link')
            outfile.write(' link=%s' % (self.gds_format_string(quote_attrib(self.link), input_name='link'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='parent', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='parent'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.link is not None and 'link' not in already_processed:
            already_processed.add('link')
            showIndent(outfile, level)
            outfile.write('link="%s",\n' % (self.link,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('link', node)
        if value is not None and 'link' not in already_processed:
            already_processed.add('link')
            self.link = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class parent


class child(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, link=None):
        self.original_tagname_ = None
        self.link = _cast(None, link)
    def factory(*args_, **kwargs_):
        if child.subclass:
            return child.subclass(*args_, **kwargs_)
        else:
            return child(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_link(self): return self.link
    def set_link(self, link): self.link = link
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='child', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='child')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='child', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='child'):
        if self.link is not None and 'link' not in already_processed:
            already_processed.add('link')
            outfile.write(' link=%s' % (self.gds_format_string(quote_attrib(self.link), input_name='link'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='child', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='child'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.link is not None and 'link' not in already_processed:
            already_processed.add('link')
            showIndent(outfile, level)
            outfile.write('link="%s",\n' % (self.link,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('link', node)
        if value is not None and 'link' not in already_processed:
            already_processed.add('link')
            self.link = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class child


class axis(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, xyz='1 0 0'):
        self.original_tagname_ = None
        self.xyz = _cast(None, xyz)
    def factory(*args_, **kwargs_):
        if axis.subclass:
            return axis.subclass(*args_, **kwargs_)
        else:
            return axis(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xyz(self): return self.xyz
    def set_xyz(self, xyz): self.xyz = xyz
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='axis', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='axis')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='axis', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='axis'):
        if self.xyz is not None and 'xyz' not in already_processed:
            already_processed.add('xyz')
            outfile.write(' xyz=%s' % (self.gds_format_string(quote_attrib(self.xyz), input_name='xyz'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='axis', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='axis'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.xyz is not None and 'xyz' not in already_processed:
            already_processed.add('xyz')
            showIndent(outfile, level)
            outfile.write('xyz="%s",\n' % (self.xyz,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xyz', node)
        if value is not None and 'xyz' not in already_processed:
            already_processed.add('xyz')
            self.xyz = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class axis


class calibration(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, reference_position=None, falling=None, rising=None):
        self.original_tagname_ = None
        self.reference_position = _cast(float, reference_position)
        self.falling = _cast(float, falling)
        self.rising = _cast(float, rising)
    def factory(*args_, **kwargs_):
        if calibration.subclass:
            return calibration.subclass(*args_, **kwargs_)
        else:
            return calibration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reference_position(self): return self.reference_position
    def set_reference_position(self, reference_position): self.reference_position = reference_position
    def get_falling(self): return self.falling
    def set_falling(self, falling): self.falling = falling
    def get_rising(self): return self.rising
    def set_rising(self, rising): self.rising = rising
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='calibration', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='calibration')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='calibration', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='calibration'):
        if self.reference_position is not None and 'reference_position' not in already_processed:
            already_processed.add('reference_position')
            outfile.write(' reference_position="%s"' % self.gds_format_double(self.reference_position, input_name='reference_position'))
        if self.falling is not None and 'falling' not in already_processed:
            already_processed.add('falling')
            outfile.write(' falling="%s"' % self.gds_format_double(self.falling, input_name='falling'))
        if self.rising is not None and 'rising' not in already_processed:
            already_processed.add('rising')
            outfile.write(' rising="%s"' % self.gds_format_double(self.rising, input_name='rising'))
    def exportChildren(self, outfile, level, namespace_='', name_='calibration', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='calibration'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.reference_position is not None and 'reference_position' not in already_processed:
            already_processed.add('reference_position')
            showIndent(outfile, level)
            outfile.write('reference_position=%e,\n' % (self.reference_position,))
        if self.falling is not None and 'falling' not in already_processed:
            already_processed.add('falling')
            showIndent(outfile, level)
            outfile.write('falling=%e,\n' % (self.falling,))
        if self.rising is not None and 'rising' not in already_processed:
            already_processed.add('rising')
            showIndent(outfile, level)
            outfile.write('rising=%e,\n' % (self.rising,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('reference_position', node)
        if value is not None and 'reference_position' not in already_processed:
            already_processed.add('reference_position')
            try:
                self.reference_position = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (reference_position): %s' % exp)
        value = find_attr_value_('falling', node)
        if value is not None and 'falling' not in already_processed:
            already_processed.add('falling')
            try:
                self.falling = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (falling): %s' % exp)
        value = find_attr_value_('rising', node)
        if value is not None and 'rising' not in already_processed:
            already_processed.add('rising')
            try:
                self.rising = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (rising): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class calibration


class dynamics(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, damping=0, friction=0):
        self.original_tagname_ = None
        self.damping = _cast(float, damping)
        self.friction = _cast(float, friction)
    def factory(*args_, **kwargs_):
        if dynamics.subclass:
            return dynamics.subclass(*args_, **kwargs_)
        else:
            return dynamics(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_damping(self): return self.damping
    def set_damping(self, damping): self.damping = damping
    def get_friction(self): return self.friction
    def set_friction(self, friction): self.friction = friction
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='dynamics', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dynamics')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='dynamics', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dynamics'):
        if self.damping is not None and 'damping' not in already_processed:
            already_processed.add('damping')
            outfile.write(' damping="%s"' % self.gds_format_double(self.damping, input_name='damping'))
        if self.friction is not None and 'friction' not in already_processed:
            already_processed.add('friction')
            outfile.write(' friction="%s"' % self.gds_format_double(self.friction, input_name='friction'))
    def exportChildren(self, outfile, level, namespace_='', name_='dynamics', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='dynamics'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.damping is not None and 'damping' not in already_processed:
            already_processed.add('damping')
            showIndent(outfile, level)
            outfile.write('damping=%e,\n' % (self.damping,))
        if self.friction is not None and 'friction' not in already_processed:
            already_processed.add('friction')
            showIndent(outfile, level)
            outfile.write('friction=%e,\n' % (self.friction,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('damping', node)
        if value is not None and 'damping' not in already_processed:
            already_processed.add('damping')
            try:
                self.damping = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (damping): %s' % exp)
        value = find_attr_value_('friction', node)
        if value is not None and 'friction' not in already_processed:
            already_processed.add('friction')
            try:
                self.friction = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (friction): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dynamics


class limit(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, upper=0, lower=0, effort=0, velocity=0):
        self.original_tagname_ = None
        self.upper = _cast(float, upper)
        self.lower = _cast(float, lower)
        self.effort = _cast(float, effort)
        self.velocity = _cast(float, velocity)
    def factory(*args_, **kwargs_):
        if limit.subclass:
            return limit.subclass(*args_, **kwargs_)
        else:
            return limit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_upper(self): return self.upper
    def set_upper(self, upper): self.upper = upper
    def get_lower(self): return self.lower
    def set_lower(self, lower): self.lower = lower
    def get_effort(self): return self.effort
    def set_effort(self, effort): self.effort = effort
    def get_velocity(self): return self.velocity
    def set_velocity(self, velocity): self.velocity = velocity
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='limit', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='limit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='limit', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='limit'):
        if self.upper is not None and 'upper' not in already_processed:
            already_processed.add('upper')
            outfile.write(' upper="%s"' % self.gds_format_double(self.upper, input_name='upper'))
        if self.lower is not None and 'lower' not in already_processed:
            already_processed.add('lower')
            outfile.write(' lower="%s"' % self.gds_format_double(self.lower, input_name='lower'))
        if self.effort is not None and 'effort' not in already_processed:
            already_processed.add('effort')
            outfile.write(' effort="%s"' % self.gds_format_double(self.effort, input_name='effort'))
        if self.velocity is not None and 'velocity' not in already_processed:
            already_processed.add('velocity')
            outfile.write(' velocity="%s"' % self.gds_format_double(self.velocity, input_name='velocity'))
    def exportChildren(self, outfile, level, namespace_='', name_='limit', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='limit'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.upper is not None and 'upper' not in already_processed:
            already_processed.add('upper')
            showIndent(outfile, level)
            outfile.write('upper=%e,\n' % (self.upper,))
        if self.lower is not None and 'lower' not in already_processed:
            already_processed.add('lower')
            showIndent(outfile, level)
            outfile.write('lower=%e,\n' % (self.lower,))
        if self.effort is not None and 'effort' not in already_processed:
            already_processed.add('effort')
            showIndent(outfile, level)
            outfile.write('effort=%e,\n' % (self.effort,))
        if self.velocity is not None and 'velocity' not in already_processed:
            already_processed.add('velocity')
            showIndent(outfile, level)
            outfile.write('velocity=%e,\n' % (self.velocity,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('upper', node)
        if value is not None and 'upper' not in already_processed:
            already_processed.add('upper')
            try:
                self.upper = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (upper): %s' % exp)
        value = find_attr_value_('lower', node)
        if value is not None and 'lower' not in already_processed:
            already_processed.add('lower')
            try:
                self.lower = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (lower): %s' % exp)
        value = find_attr_value_('effort', node)
        if value is not None and 'effort' not in already_processed:
            already_processed.add('effort')
            try:
                self.effort = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (effort): %s' % exp)
        value = find_attr_value_('velocity', node)
        if value is not None and 'velocity' not in already_processed:
            already_processed.add('velocity')
            try:
                self.velocity = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (velocity): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class limit


class safety_controller(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, soft_upper_limit=0, k_position=0, soft_lower_limit=0, k_velocity=None):
        self.original_tagname_ = None
        self.soft_upper_limit = _cast(float, soft_upper_limit)
        self.k_position = _cast(float, k_position)
        self.soft_lower_limit = _cast(float, soft_lower_limit)
        self.k_velocity = _cast(float, k_velocity)
    def factory(*args_, **kwargs_):
        if safety_controller.subclass:
            return safety_controller.subclass(*args_, **kwargs_)
        else:
            return safety_controller(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_soft_upper_limit(self): return self.soft_upper_limit
    def set_soft_upper_limit(self, soft_upper_limit): self.soft_upper_limit = soft_upper_limit
    def get_k_position(self): return self.k_position
    def set_k_position(self, k_position): self.k_position = k_position
    def get_soft_lower_limit(self): return self.soft_lower_limit
    def set_soft_lower_limit(self, soft_lower_limit): self.soft_lower_limit = soft_lower_limit
    def get_k_velocity(self): return self.k_velocity
    def set_k_velocity(self, k_velocity): self.k_velocity = k_velocity
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='safety_controller', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='safety_controller')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='safety_controller', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='safety_controller'):
        if self.soft_upper_limit is not None and 'soft_upper_limit' not in already_processed:
            already_processed.add('soft_upper_limit')
            outfile.write(' soft_upper_limit="%s"' % self.gds_format_double(self.soft_upper_limit, input_name='soft_upper_limit'))
        if self.k_position is not None and 'k_position' not in already_processed:
            already_processed.add('k_position')
            outfile.write(' k_position="%s"' % self.gds_format_double(self.k_position, input_name='k_position'))
        if self.soft_lower_limit is not None and 'soft_lower_limit' not in already_processed:
            already_processed.add('soft_lower_limit')
            outfile.write(' soft_lower_limit="%s"' % self.gds_format_double(self.soft_lower_limit, input_name='soft_lower_limit'))
        if self.k_velocity is not None and 'k_velocity' not in already_processed:
            already_processed.add('k_velocity')
            outfile.write(' k_velocity="%s"' % self.gds_format_double(self.k_velocity, input_name='k_velocity'))
    def exportChildren(self, outfile, level, namespace_='', name_='safety_controller', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='safety_controller'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.soft_upper_limit is not None and 'soft_upper_limit' not in already_processed:
            already_processed.add('soft_upper_limit')
            showIndent(outfile, level)
            outfile.write('soft_upper_limit=%e,\n' % (self.soft_upper_limit,))
        if self.k_position is not None and 'k_position' not in already_processed:
            already_processed.add('k_position')
            showIndent(outfile, level)
            outfile.write('k_position=%e,\n' % (self.k_position,))
        if self.soft_lower_limit is not None and 'soft_lower_limit' not in already_processed:
            already_processed.add('soft_lower_limit')
            showIndent(outfile, level)
            outfile.write('soft_lower_limit=%e,\n' % (self.soft_lower_limit,))
        if self.k_velocity is not None and 'k_velocity' not in already_processed:
            already_processed.add('k_velocity')
            showIndent(outfile, level)
            outfile.write('k_velocity=%e,\n' % (self.k_velocity,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('soft_upper_limit', node)
        if value is not None and 'soft_upper_limit' not in already_processed:
            already_processed.add('soft_upper_limit')
            try:
                self.soft_upper_limit = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (soft_upper_limit): %s' % exp)
        value = find_attr_value_('k_position', node)
        if value is not None and 'k_position' not in already_processed:
            already_processed.add('k_position')
            try:
                self.k_position = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (k_position): %s' % exp)
        value = find_attr_value_('soft_lower_limit', node)
        if value is not None and 'soft_lower_limit' not in already_processed:
            already_processed.add('soft_lower_limit')
            try:
                self.soft_lower_limit = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (soft_lower_limit): %s' % exp)
        value = find_attr_value_('k_velocity', node)
        if value is not None and 'k_velocity' not in already_processed:
            already_processed.add('k_velocity')
            try:
                self.k_velocity = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (k_velocity): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class safety_controller


class mimic(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, joint=None, offset=0, multiplier=1):
        self.original_tagname_ = None
        self.joint = _cast(None, joint)
        self.offset = _cast(float, offset)
        self.multiplier = _cast(float, multiplier)
    def factory(*args_, **kwargs_):
        if mimic.subclass:
            return mimic.subclass(*args_, **kwargs_)
        else:
            return mimic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_joint(self): return self.joint
    def set_joint(self, joint): self.joint = joint
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def get_multiplier(self): return self.multiplier
    def set_multiplier(self, multiplier): self.multiplier = multiplier
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='mimic', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mimic')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='mimic', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='mimic'):
        if self.joint is not None and 'joint' not in already_processed:
            already_processed.add('joint')
            outfile.write(' joint=%s' % (self.gds_format_string(quote_attrib(self.joint), input_name='joint'), ))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_double(self.offset, input_name='offset'))
        if self.multiplier is not None and 'multiplier' not in already_processed:
            already_processed.add('multiplier')
            outfile.write(' multiplier="%s"' % self.gds_format_double(self.multiplier, input_name='multiplier'))
    def exportChildren(self, outfile, level, namespace_='', name_='mimic', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='mimic'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.joint is not None and 'joint' not in already_processed:
            already_processed.add('joint')
            showIndent(outfile, level)
            outfile.write('joint="%s",\n' % (self.joint,))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            showIndent(outfile, level)
            outfile.write('offset=%e,\n' % (self.offset,))
        if self.multiplier is not None and 'multiplier' not in already_processed:
            already_processed.add('multiplier')
            showIndent(outfile, level)
            outfile.write('multiplier=%e,\n' % (self.multiplier,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('joint', node)
        if value is not None and 'joint' not in already_processed:
            already_processed.add('joint')
            self.joint = value
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (offset): %s' % exp)
        value = find_attr_value_('multiplier', node)
        if value is not None and 'multiplier' not in already_processed:
            already_processed.add('multiplier')
            try:
                self.multiplier = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (multiplier): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class mimic


class actuator_transmission(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mechanicalReduction=None, name=None):
        self.original_tagname_ = None
        self.mechanicalReduction = _cast(float, mechanicalReduction)
        self.name = _cast(None, name)
    def factory(*args_, **kwargs_):
        if actuator_transmission.subclass:
            return actuator_transmission.subclass(*args_, **kwargs_)
        else:
            return actuator_transmission(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mechanicalReduction(self): return self.mechanicalReduction
    def set_mechanicalReduction(self, mechanicalReduction): self.mechanicalReduction = mechanicalReduction
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='actuator_transmission', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='actuator_transmission')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='actuator_transmission', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='actuator_transmission'):
        if self.mechanicalReduction is not None and 'mechanicalReduction' not in already_processed:
            already_processed.add('mechanicalReduction')
            outfile.write(' mechanicalReduction="%s"' % self.gds_format_double(self.mechanicalReduction, input_name='mechanicalReduction'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='actuator_transmission', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='actuator_transmission'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.mechanicalReduction is not None and 'mechanicalReduction' not in already_processed:
            already_processed.add('mechanicalReduction')
            showIndent(outfile, level)
            outfile.write('mechanicalReduction=%e,\n' % (self.mechanicalReduction,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mechanicalReduction', node)
        if value is not None and 'mechanicalReduction' not in already_processed:
            already_processed.add('mechanicalReduction')
            try:
                self.mechanicalReduction = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (mechanicalReduction): %s' % exp)
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class actuator_transmission


class gap_joint_transmission(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, a=None, theta0=None, b=None, name=None, h=None, phi0=None, t0=None, gear_ratio=None, r=None, L0=None, mechanical_reduction=None, screw_reduction=None):
        self.original_tagname_ = None
        self.a = _cast(float, a)
        self.theta0 = _cast(float, theta0)
        self.b = _cast(float, b)
        self.name = _cast(None, name)
        self.h = _cast(float, h)
        self.phi0 = _cast(float, phi0)
        self.t0 = _cast(float, t0)
        self.gear_ratio = _cast(float, gear_ratio)
        self.r = _cast(float, r)
        self.L0 = _cast(float, L0)
        self.mechanical_reduction = _cast(float, mechanical_reduction)
        self.screw_reduction = _cast(float, screw_reduction)
    def factory(*args_, **kwargs_):
        if gap_joint_transmission.subclass:
            return gap_joint_transmission.subclass(*args_, **kwargs_)
        else:
            return gap_joint_transmission(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_a(self): return self.a
    def set_a(self, a): self.a = a
    def get_theta0(self): return self.theta0
    def set_theta0(self, theta0): self.theta0 = theta0
    def get_b(self): return self.b
    def set_b(self, b): self.b = b
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_h(self): return self.h
    def set_h(self, h): self.h = h
    def get_phi0(self): return self.phi0
    def set_phi0(self, phi0): self.phi0 = phi0
    def get_t0(self): return self.t0
    def set_t0(self, t0): self.t0 = t0
    def get_gear_ratio(self): return self.gear_ratio
    def set_gear_ratio(self, gear_ratio): self.gear_ratio = gear_ratio
    def get_r(self): return self.r
    def set_r(self, r): self.r = r
    def get_L0(self): return self.L0
    def set_L0(self, L0): self.L0 = L0
    def get_mechanical_reduction(self): return self.mechanical_reduction
    def set_mechanical_reduction(self, mechanical_reduction): self.mechanical_reduction = mechanical_reduction
    def get_screw_reduction(self): return self.screw_reduction
    def set_screw_reduction(self, screw_reduction): self.screw_reduction = screw_reduction
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='gap_joint_transmission', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='gap_joint_transmission')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='gap_joint_transmission', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='gap_joint_transmission'):
        if self.a is not None and 'a' not in already_processed:
            already_processed.add('a')
            outfile.write(' a="%s"' % self.gds_format_double(self.a, input_name='a'))
        if self.theta0 is not None and 'theta0' not in already_processed:
            already_processed.add('theta0')
            outfile.write(' theta0="%s"' % self.gds_format_double(self.theta0, input_name='theta0'))
        if self.b is not None and 'b' not in already_processed:
            already_processed.add('b')
            outfile.write(' b="%s"' % self.gds_format_double(self.b, input_name='b'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name), input_name='name'), ))
        if self.h is not None and 'h' not in already_processed:
            already_processed.add('h')
            outfile.write(' h="%s"' % self.gds_format_double(self.h, input_name='h'))
        if self.phi0 is not None and 'phi0' not in already_processed:
            already_processed.add('phi0')
            outfile.write(' phi0="%s"' % self.gds_format_double(self.phi0, input_name='phi0'))
        if self.t0 is not None and 't0' not in already_processed:
            already_processed.add('t0')
            outfile.write(' t0="%s"' % self.gds_format_double(self.t0, input_name='t0'))
        if self.gear_ratio is not None and 'gear_ratio' not in already_processed:
            already_processed.add('gear_ratio')
            outfile.write(' gear_ratio="%s"' % self.gds_format_double(self.gear_ratio, input_name='gear_ratio'))
        if self.r is not None and 'r' not in already_processed:
            already_processed.add('r')
            outfile.write(' r="%s"' % self.gds_format_double(self.r, input_name='r'))
        if self.L0 is not None and 'L0' not in already_processed:
            already_processed.add('L0')
            outfile.write(' L0="%s"' % self.gds_format_double(self.L0, input_name='L0'))
        if self.mechanical_reduction is not None and 'mechanical_reduction' not in already_processed:
            already_processed.add('mechanical_reduction')
            outfile.write(' mechanical_reduction="%s"' % self.gds_format_double(self.mechanical_reduction, input_name='mechanical_reduction'))
        if self.screw_reduction is not None and 'screw_reduction' not in already_processed:
            already_processed.add('screw_reduction')
            outfile.write(' screw_reduction="%s"' % self.gds_format_double(self.screw_reduction, input_name='screw_reduction'))
    def exportChildren(self, outfile, level, namespace_='', name_='gap_joint_transmission', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='gap_joint_transmission'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.a is not None and 'a' not in already_processed:
            already_processed.add('a')
            showIndent(outfile, level)
            outfile.write('a=%e,\n' % (self.a,))
        if self.theta0 is not None and 'theta0' not in already_processed:
            already_processed.add('theta0')
            showIndent(outfile, level)
            outfile.write('theta0=%e,\n' % (self.theta0,))
        if self.b is not None and 'b' not in already_processed:
            already_processed.add('b')
            showIndent(outfile, level)
            outfile.write('b=%e,\n' % (self.b,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.h is not None and 'h' not in already_processed:
            already_processed.add('h')
            showIndent(outfile, level)
            outfile.write('h=%e,\n' % (self.h,))
        if self.phi0 is not None and 'phi0' not in already_processed:
            already_processed.add('phi0')
            showIndent(outfile, level)
            outfile.write('phi0=%e,\n' % (self.phi0,))
        if self.t0 is not None and 't0' not in already_processed:
            already_processed.add('t0')
            showIndent(outfile, level)
            outfile.write('t0=%e,\n' % (self.t0,))
        if self.gear_ratio is not None and 'gear_ratio' not in already_processed:
            already_processed.add('gear_ratio')
            showIndent(outfile, level)
            outfile.write('gear_ratio=%e,\n' % (self.gear_ratio,))
        if self.r is not None and 'r' not in already_processed:
            already_processed.add('r')
            showIndent(outfile, level)
            outfile.write('r=%e,\n' % (self.r,))
        if self.L0 is not None and 'L0' not in already_processed:
            already_processed.add('L0')
            showIndent(outfile, level)
            outfile.write('L0=%e,\n' % (self.L0,))
        if self.mechanical_reduction is not None and 'mechanical_reduction' not in already_processed:
            already_processed.add('mechanical_reduction')
            showIndent(outfile, level)
            outfile.write('mechanical_reduction=%e,\n' % (self.mechanical_reduction,))
        if self.screw_reduction is not None and 'screw_reduction' not in already_processed:
            already_processed.add('screw_reduction')
            showIndent(outfile, level)
            outfile.write('screw_reduction=%e,\n' % (self.screw_reduction,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.add('a')
            try:
                self.a = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (a): %s' % exp)
        value = find_attr_value_('theta0', node)
        if value is not None and 'theta0' not in already_processed:
            already_processed.add('theta0')
            try:
                self.theta0 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (theta0): %s' % exp)
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.add('b')
            try:
                self.b = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (b): %s' % exp)
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('h', node)
        if value is not None and 'h' not in already_processed:
            already_processed.add('h')
            try:
                self.h = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (h): %s' % exp)
        value = find_attr_value_('phi0', node)
        if value is not None and 'phi0' not in already_processed:
            already_processed.add('phi0')
            try:
                self.phi0 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (phi0): %s' % exp)
        value = find_attr_value_('t0', node)
        if value is not None and 't0' not in already_processed:
            already_processed.add('t0')
            try:
                self.t0 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (t0): %s' % exp)
        value = find_attr_value_('gear_ratio', node)
        if value is not None and 'gear_ratio' not in already_processed:
            already_processed.add('gear_ratio')
            try:
                self.gear_ratio = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (gear_ratio): %s' % exp)
        value = find_attr_value_('r', node)
        if value is not None and 'r' not in already_processed:
            already_processed.add('r')
            try:
                self.r = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (r): %s' % exp)
        value = find_attr_value_('L0', node)
        if value is not None and 'L0' not in already_processed:
            already_processed.add('L0')
            try:
                self.L0 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (L0): %s' % exp)
        value = find_attr_value_('mechanical_reduction', node)
        if value is not None and 'mechanical_reduction' not in already_processed:
            already_processed.add('mechanical_reduction')
            try:
                self.mechanical_reduction = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (mechanical_reduction): %s' % exp)
        value = find_attr_value_('screw_reduction', node)
        if value is not None and 'screw_reduction' not in already_processed:
            already_processed.add('screw_reduction')
            try:
                self.screw_reduction = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (screw_reduction): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class gap_joint_transmission


class passive_joint_transmission(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
    def factory(*args_, **kwargs_):
        if passive_joint_transmission.subclass:
            return passive_joint_transmission.subclass(*args_, **kwargs_)
        else:
            return passive_joint_transmission(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='passive_joint_transmission', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='passive_joint_transmission')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='passive_joint_transmission', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='passive_joint_transmission'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='passive_joint_transmission', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='passive_joint_transmission'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class passive_joint_transmission


class transmission(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, name=None, leftActuator=None, rightActuator=None, flexJoint=None, rollJoint=None, gap_joint=None, passive_joint=None, use_simulated_gripper_joint=None, mechanicalReduction=None, actuator=None, joint=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.name = _cast(None, name)
        self.leftActuator = leftActuator
        self.rightActuator = rightActuator
        self.flexJoint = flexJoint
        self.rollJoint = rollJoint
        self.gap_joint = gap_joint
        if passive_joint is None:
            self.passive_joint = []
        else:
            self.passive_joint = passive_joint
        self.use_simulated_gripper_joint = use_simulated_gripper_joint
        self.mechanicalReduction = mechanicalReduction
        self.actuator = actuator
        self.joint = joint
    def factory(*args_, **kwargs_):
        if transmission.subclass:
            return transmission.subclass(*args_, **kwargs_)
        else:
            return transmission(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_leftActuator(self): return self.leftActuator
    def set_leftActuator(self, leftActuator): self.leftActuator = leftActuator
    def get_rightActuator(self): return self.rightActuator
    def set_rightActuator(self, rightActuator): self.rightActuator = rightActuator
    def get_flexJoint(self): return self.flexJoint
    def set_flexJoint(self, flexJoint): self.flexJoint = flexJoint
    def get_rollJoint(self): return self.rollJoint
    def set_rollJoint(self, rollJoint): self.rollJoint = rollJoint
    def get_gap_joint(self): return self.gap_joint
    def set_gap_joint(self, gap_joint): self.gap_joint = gap_joint
    def get_passive_joint(self): return self.passive_joint
    def set_passive_joint(self, passive_joint): self.passive_joint = passive_joint
    def add_passive_joint(self, value): self.passive_joint.append(value)
    def insert_passive_joint_at(self, index, value): self.passive_joint.insert(index, value)
    def replace_passive_joint_at(self, index, value): self.passive_joint[index] = value
    def get_use_simulated_gripper_joint(self): return self.use_simulated_gripper_joint
    def set_use_simulated_gripper_joint(self, use_simulated_gripper_joint): self.use_simulated_gripper_joint = use_simulated_gripper_joint
    def get_mechanicalReduction(self): return self.mechanicalReduction
    def set_mechanicalReduction(self, mechanicalReduction): self.mechanicalReduction = mechanicalReduction
    def get_actuator(self): return self.actuator
    def set_actuator(self, actuator): self.actuator = actuator
    def get_joint(self): return self.joint
    def set_joint(self, joint): self.joint = joint
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            self.leftActuator is not None or
            self.rightActuator is not None or
            self.flexJoint is not None or
            self.rollJoint is not None or
            self.gap_joint is not None or
            self.passive_joint or
            self.use_simulated_gripper_joint is not None or
            self.mechanicalReduction is not None or
            self.actuator is not None or
            self.joint is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='transmission', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='transmission')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='transmission', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='transmission'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_), input_name='type'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='transmission', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.leftActuator is not None:
            self.leftActuator.export(outfile, level, namespace_, name_='leftActuator', pretty_print=pretty_print)
        if self.rightActuator is not None:
            self.rightActuator.export(outfile, level, namespace_, name_='rightActuator', pretty_print=pretty_print)
        if self.flexJoint is not None:
            self.flexJoint.export(outfile, level, namespace_, name_='flexJoint', pretty_print=pretty_print)
        if self.rollJoint is not None:
            self.rollJoint.export(outfile, level, namespace_, name_='rollJoint', pretty_print=pretty_print)
        if self.gap_joint is not None:
            self.gap_joint.export(outfile, level, namespace_, name_='gap_joint', pretty_print=pretty_print)
        for passive_joint_ in self.passive_joint:
            passive_joint_.export(outfile, level, namespace_, name_='passive_joint', pretty_print=pretty_print)
        if self.use_simulated_gripper_joint is not None:
            self.use_simulated_gripper_joint.export(outfile, level, namespace_, name_='use_simulated_gripper_joint', pretty_print=pretty_print)
        if self.mechanicalReduction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smechanicalReduction>%s</%smechanicalReduction>%s' % (namespace_, self.gds_format_double(self.mechanicalReduction, input_name='mechanicalReduction'), namespace_, eol_))
        if self.actuator is not None:
            self.actuator.export(outfile, level, namespace_, name_='actuator', pretty_print=pretty_print)
        if self.joint is not None:
            self.joint.export(outfile, level, namespace_, name_='joint', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='transmission'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.leftActuator is not None:
            showIndent(outfile, level)
            outfile.write('leftActuator=model_.actuator_transmission(\n')
            self.leftActuator.exportLiteral(outfile, level, name_='leftActuator')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rightActuator is not None:
            showIndent(outfile, level)
            outfile.write('rightActuator=model_.actuator_transmission(\n')
            self.rightActuator.exportLiteral(outfile, level, name_='rightActuator')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.flexJoint is not None:
            showIndent(outfile, level)
            outfile.write('flexJoint=model_.actuator_transmission(\n')
            self.flexJoint.exportLiteral(outfile, level, name_='flexJoint')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rollJoint is not None:
            showIndent(outfile, level)
            outfile.write('rollJoint=model_.actuator_transmission(\n')
            self.rollJoint.exportLiteral(outfile, level, name_='rollJoint')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.gap_joint is not None:
            showIndent(outfile, level)
            outfile.write('gap_joint=model_.gap_joint_transmission(\n')
            self.gap_joint.exportLiteral(outfile, level, name_='gap_joint')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('passive_joint=[\n')
        level += 1
        for passive_joint_ in self.passive_joint:
            showIndent(outfile, level)
            outfile.write('model_.passive_joint_transmission(\n')
            passive_joint_.exportLiteral(outfile, level, name_='passive_joint_transmission')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.use_simulated_gripper_joint is not None:
            showIndent(outfile, level)
            outfile.write('use_simulated_gripper_joint=model_.use_simulated_gripper_jointType(\n')
            self.use_simulated_gripper_joint.exportLiteral(outfile, level, name_='use_simulated_gripper_joint')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.mechanicalReduction is not None:
            showIndent(outfile, level)
            outfile.write('mechanicalReduction=%e,\n' % self.mechanicalReduction)
        if self.actuator is not None:
            showIndent(outfile, level)
            outfile.write('actuator=model_.name(\n')
            self.actuator.exportLiteral(outfile, level, name_='actuator')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.joint is not None:
            showIndent(outfile, level)
            outfile.write('joint=model_.name(\n')
            self.joint.exportLiteral(outfile, level, name_='joint')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'leftActuator':
            obj_ = actuator_transmission.factory()
            obj_.build(child_)
            self.leftActuator = obj_
            obj_.original_tagname_ = 'leftActuator'
        elif nodeName_ == 'rightActuator':
            obj_ = actuator_transmission.factory()
            obj_.build(child_)
            self.rightActuator = obj_
            obj_.original_tagname_ = 'rightActuator'
        elif nodeName_ == 'flexJoint':
            obj_ = actuator_transmission.factory()
            obj_.build(child_)
            self.flexJoint = obj_
            obj_.original_tagname_ = 'flexJoint'
        elif nodeName_ == 'rollJoint':
            obj_ = actuator_transmission.factory()
            obj_.build(child_)
            self.rollJoint = obj_
            obj_.original_tagname_ = 'rollJoint'
        elif nodeName_ == 'gap_joint':
            obj_ = gap_joint_transmission.factory()
            obj_.build(child_)
            self.gap_joint = obj_
            obj_.original_tagname_ = 'gap_joint'
        elif nodeName_ == 'passive_joint':
            obj_ = passive_joint_transmission.factory()
            obj_.build(child_)
            self.passive_joint.append(obj_)
            obj_.original_tagname_ = 'passive_joint'
        elif nodeName_ == 'use_simulated_gripper_joint':
            obj_ = use_simulated_gripper_jointType.factory()
            obj_.build(child_)
            self.use_simulated_gripper_joint = obj_
            obj_.original_tagname_ = 'use_simulated_gripper_joint'
        elif nodeName_ == 'mechanicalReduction':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'mechanicalReduction')
            self.mechanicalReduction = fval_
        elif nodeName_ == 'actuator':
            obj_ = name.factory()
            obj_.build(child_)
            self.actuator = obj_
            obj_.original_tagname_ = 'actuator'
        elif nodeName_ == 'joint':
            obj_ = name.factory()
            obj_.build(child_)
            self.joint = obj_
            obj_.original_tagname_ = 'joint'
# end class transmission


class joint(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, name=None, origin=None, parent=None, child=None, axis=None, calibration=None, dynamics=None, limit=None, safety_controller=None, mimic=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.name = _cast(None, name)
        self.origin = origin
        self.parent = parent
        self.child = child
        self.axis = axis
        self.calibration = calibration
        self.dynamics = dynamics
        self.limit = limit
        self.safety_controller = safety_controller
        self.mimic = mimic
    def factory(*args_, **kwargs_):
        if joint.subclass:
            return joint.subclass(*args_, **kwargs_)
        else:
            return joint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_origin(self): return self.origin
    def set_origin(self, origin): self.origin = origin
    def get_parent(self): return self.parent
    def set_parent(self, parent): self.parent = parent
    def get_child(self): return self.child
    def set_child(self, child): self.child = child
    def get_axis(self): return self.axis
    def set_axis(self, axis): self.axis = axis
    def get_calibration(self): return self.calibration
    def set_calibration(self, calibration): self.calibration = calibration
    def get_dynamics(self): return self.dynamics
    def set_dynamics(self, dynamics): self.dynamics = dynamics
    def get_limit(self): return self.limit
    def set_limit(self, limit): self.limit = limit
    def get_safety_controller(self): return self.safety_controller
    def set_safety_controller(self, safety_controller): self.safety_controller = safety_controller
    def get_mimic(self): return self.mimic
    def set_mimic(self, mimic): self.mimic = mimic
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            self.origin is not None or
            self.parent is not None or
            self.child is not None or
            self.axis is not None or
            self.calibration is not None or
            self.dynamics is not None or
            self.limit is not None or
            self.safety_controller is not None or
            self.mimic is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='joint', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='joint')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='joint', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='joint'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_), input_name='type'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='joint', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.origin is not None:
            self.origin.export(outfile, level, namespace_, name_='origin', pretty_print=pretty_print)
        if self.parent is not None:
            self.parent.export(outfile, level, namespace_, name_='parent', pretty_print=pretty_print)
        if self.child is not None:
            self.child.export(outfile, level, namespace_, name_='child', pretty_print=pretty_print)
        if self.axis is not None:
            self.axis.export(outfile, level, namespace_, name_='axis', pretty_print=pretty_print)
        if self.calibration is not None:
            self.calibration.export(outfile, level, namespace_, name_='calibration', pretty_print=pretty_print)
        if self.dynamics is not None:
            self.dynamics.export(outfile, level, namespace_, name_='dynamics', pretty_print=pretty_print)
        if self.limit is not None:
            self.limit.export(outfile, level, namespace_, name_='limit', pretty_print=pretty_print)
        if self.safety_controller is not None:
            self.safety_controller.export(outfile, level, namespace_, name_='safety_controller', pretty_print=pretty_print)
        if self.mimic is not None:
            self.mimic.export(outfile, level, namespace_, name_='mimic', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='joint'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.origin is not None:
            showIndent(outfile, level)
            outfile.write('origin=model_.pose(\n')
            self.origin.exportLiteral(outfile, level, name_='origin')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.parent is not None:
            showIndent(outfile, level)
            outfile.write('parent=model_.parent(\n')
            self.parent.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.child is not None:
            showIndent(outfile, level)
            outfile.write('child=model_.child(\n')
            self.child.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.axis is not None:
            showIndent(outfile, level)
            outfile.write('axis=model_.axis(\n')
            self.axis.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.calibration is not None:
            showIndent(outfile, level)
            outfile.write('calibration=model_.calibration(\n')
            self.calibration.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dynamics is not None:
            showIndent(outfile, level)
            outfile.write('dynamics=model_.dynamics(\n')
            self.dynamics.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.limit is not None:
            showIndent(outfile, level)
            outfile.write('limit=model_.limit(\n')
            self.limit.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.safety_controller is not None:
            showIndent(outfile, level)
            outfile.write('safety_controller=model_.safety_controller(\n')
            self.safety_controller.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.mimic is not None:
            showIndent(outfile, level)
            outfile.write('mimic=model_.mimic(\n')
            self.mimic.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'origin':
            obj_ = pose.factory()
            obj_.build(child_)
            self.origin = obj_
            obj_.original_tagname_ = 'origin'
        elif nodeName_ == 'parent':
            obj_ = parent.factory()
            obj_.build(child_)
            self.parent = obj_
            obj_.original_tagname_ = 'parent'
        elif nodeName_ == 'child':
            obj_ = child.factory()
            obj_.build(child_)
            self.child = obj_
            obj_.original_tagname_ = 'child'
        elif nodeName_ == 'axis':
            obj_ = axis.factory()
            obj_.build(child_)
            self.axis = obj_
            obj_.original_tagname_ = 'axis'
        elif nodeName_ == 'calibration':
            obj_ = calibration.factory()
            obj_.build(child_)
            self.calibration = obj_
            obj_.original_tagname_ = 'calibration'
        elif nodeName_ == 'dynamics':
            obj_ = dynamics.factory()
            obj_.build(child_)
            self.dynamics = obj_
            obj_.original_tagname_ = 'dynamics'
        elif nodeName_ == 'limit':
            obj_ = limit.factory()
            obj_.build(child_)
            self.limit = obj_
            obj_.original_tagname_ = 'limit'
        elif nodeName_ == 'safety_controller':
            obj_ = safety_controller.factory()
            obj_.build(child_)
            self.safety_controller = obj_
            obj_.original_tagname_ = 'safety_controller'
        elif nodeName_ == 'mimic':
            obj_ = mimic.factory()
            obj_.build(child_)
            self.mimic = obj_
            obj_.original_tagname_ = 'mimic'
# end class joint


class robot(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, version='1.0', name=None, joint=None, link=None, material=None, transmission=None):
        self.original_tagname_ = None
        self.version = _cast(None, version)
        self.name = _cast(None, name)
        if joint is None:
            self.joint = []
        else:
            self.joint = joint
        if link is None:
            self.link = []
        else:
            self.link = link
        if material is None:
            self.material = []
        else:
            self.material = material
        if transmission is None:
            self.transmission = []
        else:
            self.transmission = transmission
    def factory(*args_, **kwargs_):
        if robot.subclass:
            return robot.subclass(*args_, **kwargs_)
        else:
            return robot(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_joint(self): return self.joint
    def set_joint(self, joint): self.joint = joint
    def add_joint(self, value): self.joint.append(value)
    def insert_joint_at(self, index, value): self.joint.insert(index, value)
    def replace_joint_at(self, index, value): self.joint[index] = value
    def get_link(self): return self.link
    def set_link(self, link): self.link = link
    def add_link(self, value): self.link.append(value)
    def insert_link_at(self, index, value): self.link.insert(index, value)
    def replace_link_at(self, index, value): self.link[index] = value
    def get_material(self): return self.material
    def set_material(self, material): self.material = material
    def add_material(self, value): self.material.append(value)
    def insert_material_at(self, index, value): self.material.insert(index, value)
    def replace_material_at(self, index, value): self.material[index] = value
    def get_transmission(self): return self.transmission
    def set_transmission(self, transmission): self.transmission = transmission
    def add_transmission(self, value): self.transmission.append(value)
    def insert_transmission_at(self, index, value): self.transmission.insert(index, value)
    def replace_transmission_at(self, index, value): self.transmission[index] = value
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            self.joint or
            self.link or
            self.material or
            self.transmission
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='robot', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='robot')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='robot', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='robot'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version), input_name='version'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='robot', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for joint_ in self.joint:
            joint_.export(outfile, level, namespace_, name_='joint', pretty_print=pretty_print)
        for link_ in self.link:
            link_.export(outfile, level, namespace_, name_='link', pretty_print=pretty_print)
        for material_ in self.material:
            material_.export(outfile, level, namespace_, name_='material', pretty_print=pretty_print)
        for transmission_ in self.transmission:
            transmission_.export(outfile, level, namespace_, name_='transmission', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='robot'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('joint=[\n')
        level += 1
        for joint_ in self.joint:
            showIndent(outfile, level)
            outfile.write('model_.joint(\n')
            joint_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('link=[\n')
        level += 1
        for link_ in self.link:
            showIndent(outfile, level)
            outfile.write('model_.link(\n')
            link_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('material=[\n')
        level += 1
        for material_ in self.material:
            showIndent(outfile, level)
            outfile.write('model_.material_global(\n')
            material_.exportLiteral(outfile, level, name_='material_global')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('transmission=[\n')
        level += 1
        for transmission_ in self.transmission:
            showIndent(outfile, level)
            outfile.write('model_.transmission(\n')
            transmission_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'joint':
            obj_ = joint.factory()
            obj_.build(child_)
            self.joint.append(obj_)
            obj_.original_tagname_ = 'joint'
        elif nodeName_ == 'link':
            obj_ = link.factory()
            obj_.build(child_)
            self.link.append(obj_)
            obj_.original_tagname_ = 'link'
        elif nodeName_ == 'material':
            obj_ = material_global.factory()
            obj_.build(child_)
            self.material.append(obj_)
            obj_.original_tagname_ = 'material'
        elif nodeName_ == 'transmission':
            obj_ = transmission.factory()
            obj_.build(child_)
            self.transmission.append(obj_)
            obj_.original_tagname_ = 'transmission'
# end class robot


class use_simulated_gripper_jointType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if use_simulated_gripper_jointType.subclass:
            return use_simulated_gripper_jointType.subclass(*args_, **kwargs_)
        else:
            return use_simulated_gripper_jointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='use_simulated_gripper_jointType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='use_simulated_gripper_jointType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='use_simulated_gripper_jointType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='use_simulated_gripper_jointType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='use_simulated_gripper_jointType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='use_simulated_gripper_jointType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class use_simulated_gripper_jointType


GDSClassesMapping = {
    'origin': pose,
    'flexJoint': actuator_transmission,
    'rollJoint': actuator_transmission,
    'joint': name,
    'leftActuator': actuator_transmission,
    'material': material_global,
    'use_simulated_gripper_joint': use_simulated_gripper_jointType,
    'passive_joint': passive_joint_transmission,
    'rightActuator': actuator_transmission,
    'gap_joint': gap_joint_transmission,
    'actuator': name,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'pose'
        rootClass = pose
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'pose'
        rootClass = pose
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from io import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'pose'
        rootClass = pose
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'pose'
        rootClass = pose
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from urdf_dom import *\n\n')
        sys.stdout.write('import urdf_dom as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "actuator_transmission",
    "axis",
    "box",
    "calibration",
    "child",
    "collision",
    "color",
    "cylinder",
    "dynamics",
    "gap_joint_transmission",
    "geometry",
    "inertia",
    "inertial",
    "joint",
    "limit",
    "link",
    "mass",
    "material",
    "material_global",
    "mesh",
    "mimic",
    "name",
    "parent",
    "passive_joint_transmission",
    "pose",
    "robot",
    "safety_controller",
    "sphere",
    "texture",
    "transmission",
    "use_simulated_gripper_jointType",
    "verbose",
    "visual"
]
