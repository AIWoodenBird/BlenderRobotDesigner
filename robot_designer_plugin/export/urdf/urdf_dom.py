#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed Jul 15 10:08:13 2015 by generateDS.py version 2.14a.
#
# Command line options:
#   ('-f', '')
#   ('-o', 'urdf_dom.py')
#
# Command line arguments:
#   ../../../resources/urdf.xsd
#
# Command line:
#   /usr/local/bin/generateDS.py -f -o "urdf_dom.py" ../../../resources/urdf.xsd
#
# Current working directory (os.getcwd()):
#   urdf
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_


Validate_simpletypes_ = True


etree_ = None
Verbose_import_ = False
(
    XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
) = list(range(3))
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")


def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
            'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, str) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, str) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class PoseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, rpy='0 0 0', xyz='0 0 0'):
        self.original_tagname_ = None
        self.rpy = _cast(None, rpy)
        self.xyz = _cast(None, xyz)
    def factory(*args_, **kwargs_):
        if PoseType.subclass:
            return PoseType.subclass(*args_, **kwargs_)
        else:
            return PoseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rpy(self): return self.rpy
    def set_rpy(self, rpy): self.rpy = rpy
    def get_xyz(self): return self.xyz
    def set_xyz(self, xyz): self.xyz = xyz
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PoseType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PoseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PoseType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PoseType'):
        if self.rpy is not None and 'rpy' not in already_processed:
            already_processed.add('rpy')
            outfile.write(' rpy=%s' % (self.gds_format_string(quote_attrib(self.rpy), input_name='rpy'), ))
        if self.xyz is not None and 'xyz' not in already_processed:
            already_processed.add('xyz')
            outfile.write(' xyz=%s' % (self.gds_format_string(quote_attrib(self.xyz), input_name='xyz'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PoseType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='PoseType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.rpy is not None and 'rpy' not in already_processed:
            already_processed.add('rpy')
            showIndent(outfile, level)
            outfile.write('rpy="%s",\n' % (self.rpy,))
        if self.xyz is not None and 'xyz' not in already_processed:
            already_processed.add('xyz')
            showIndent(outfile, level)
            outfile.write('xyz="%s",\n' % (self.xyz,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rpy', node)
        if value is not None and 'rpy' not in already_processed:
            already_processed.add('rpy')
            self.rpy = value
        value = find_attr_value_('xyz', node)
        if value is not None and 'xyz' not in already_processed:
            already_processed.add('xyz')
            self.xyz = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PoseType


class ColorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, rgba='0 0 0 0'):
        self.original_tagname_ = None
        self.rgba = _cast(None, rgba)
    def factory(*args_, **kwargs_):
        if ColorType.subclass:
            return ColorType.subclass(*args_, **kwargs_)
        else:
            return ColorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rgba(self): return self.rgba
    def set_rgba(self, rgba): self.rgba = rgba
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ColorType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ColorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ColorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ColorType'):
        if self.rgba is not None and 'rgba' not in already_processed:
            already_processed.add('rgba')
            outfile.write(' rgba=%s' % (self.gds_format_string(quote_attrib(self.rgba), input_name='rgba'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ColorType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ColorType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.rgba is not None and 'rgba' not in already_processed:
            already_processed.add('rgba')
            showIndent(outfile, level)
            outfile.write('rgba="%s",\n' % (self.rgba,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rgba', node)
        if value is not None and 'rgba' not in already_processed:
            already_processed.add('rgba')
            self.rgba = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ColorType


class VerboseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None):
        self.original_tagname_ = None
        self.value = _cast(None, value)
    def factory(*args_, **kwargs_):
        if VerboseType.subclass:
            return VerboseType.subclass(*args_, **kwargs_)
        else:
            return VerboseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VerboseType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VerboseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VerboseType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VerboseType'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='VerboseType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='VerboseType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VerboseType


class MassType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=0):
        self.original_tagname_ = None
        self.value = _cast(float, value)
    def factory(*args_, **kwargs_):
        if MassType.subclass:
            return MassType.subclass(*args_, **kwargs_)
        else:
            return MassType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MassType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MassType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MassType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MassType'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_double(self.value, input_name='value'))
    def exportChildren(self, outfile, level, namespace_='', name_='MassType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='MassType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value=%e,\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            try:
                self.value = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MassType


class InertiaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ixz=0, ixx=0, ixy=0, izz=0, iyy=0, iyz=0):
        self.original_tagname_ = None
        self.ixz = _cast(float, ixz)
        self.ixx = _cast(float, ixx)
        self.ixy = _cast(float, ixy)
        self.izz = _cast(float, izz)
        self.iyy = _cast(float, iyy)
        self.iyz = _cast(float, iyz)
    def factory(*args_, **kwargs_):
        if InertiaType.subclass:
            return InertiaType.subclass(*args_, **kwargs_)
        else:
            return InertiaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ixz(self): return self.ixz
    def set_ixz(self, ixz): self.ixz = ixz
    def get_ixx(self): return self.ixx
    def set_ixx(self, ixx): self.ixx = ixx
    def get_ixy(self): return self.ixy
    def set_ixy(self, ixy): self.ixy = ixy
    def get_izz(self): return self.izz
    def set_izz(self, izz): self.izz = izz
    def get_iyy(self): return self.iyy
    def set_iyy(self, iyy): self.iyy = iyy
    def get_iyz(self): return self.iyz
    def set_iyz(self, iyz): self.iyz = iyz
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InertiaType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InertiaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InertiaType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InertiaType'):
        if self.ixz is not None and 'ixz' not in already_processed:
            already_processed.add('ixz')
            outfile.write(' ixz="%s"' % self.gds_format_double(self.ixz, input_name='ixz'))
        if self.ixx is not None and 'ixx' not in already_processed:
            already_processed.add('ixx')
            outfile.write(' ixx="%s"' % self.gds_format_double(self.ixx, input_name='ixx'))
        if self.ixy is not None and 'ixy' not in already_processed:
            already_processed.add('ixy')
            outfile.write(' ixy="%s"' % self.gds_format_double(self.ixy, input_name='ixy'))
        if self.izz is not None and 'izz' not in already_processed:
            already_processed.add('izz')
            outfile.write(' izz="%s"' % self.gds_format_double(self.izz, input_name='izz'))
        if self.iyy is not None and 'iyy' not in already_processed:
            already_processed.add('iyy')
            outfile.write(' iyy="%s"' % self.gds_format_double(self.iyy, input_name='iyy'))
        if self.iyz is not None and 'iyz' not in already_processed:
            already_processed.add('iyz')
            outfile.write(' iyz="%s"' % self.gds_format_double(self.iyz, input_name='iyz'))
    def exportChildren(self, outfile, level, namespace_='', name_='InertiaType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='InertiaType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ixz is not None and 'ixz' not in already_processed:
            already_processed.add('ixz')
            showIndent(outfile, level)
            outfile.write('ixz=%e,\n' % (self.ixz,))
        if self.ixx is not None and 'ixx' not in already_processed:
            already_processed.add('ixx')
            showIndent(outfile, level)
            outfile.write('ixx=%e,\n' % (self.ixx,))
        if self.ixy is not None and 'ixy' not in already_processed:
            already_processed.add('ixy')
            showIndent(outfile, level)
            outfile.write('ixy=%e,\n' % (self.ixy,))
        if self.izz is not None and 'izz' not in already_processed:
            already_processed.add('izz')
            showIndent(outfile, level)
            outfile.write('izz=%e,\n' % (self.izz,))
        if self.iyy is not None and 'iyy' not in already_processed:
            already_processed.add('iyy')
            showIndent(outfile, level)
            outfile.write('iyy=%e,\n' % (self.iyy,))
        if self.iyz is not None and 'iyz' not in already_processed:
            already_processed.add('iyz')
            showIndent(outfile, level)
            outfile.write('iyz=%e,\n' % (self.iyz,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ixz', node)
        if value is not None and 'ixz' not in already_processed:
            already_processed.add('ixz')
            try:
                self.ixz = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (ixz): %s' % exp)
        value = find_attr_value_('ixx', node)
        if value is not None and 'ixx' not in already_processed:
            already_processed.add('ixx')
            try:
                self.ixx = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (ixx): %s' % exp)
        value = find_attr_value_('ixy', node)
        if value is not None and 'ixy' not in already_processed:
            already_processed.add('ixy')
            try:
                self.ixy = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (ixy): %s' % exp)
        value = find_attr_value_('izz', node)
        if value is not None and 'izz' not in already_processed:
            already_processed.add('izz')
            try:
                self.izz = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (izz): %s' % exp)
        value = find_attr_value_('iyy', node)
        if value is not None and 'iyy' not in already_processed:
            already_processed.add('iyy')
            try:
                self.iyy = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (iyy): %s' % exp)
        value = find_attr_value_('iyz', node)
        if value is not None and 'iyz' not in already_processed:
            already_processed.add('iyz')
            try:
                self.iyz = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (iyz): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class InertiaType


class InertialType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, origin=None, mass=None, inertia=None):
        self.original_tagname_ = None
        self.origin = origin
        self.mass = mass
        self.inertia = inertia
    def factory(*args_, **kwargs_):
        if InertialType.subclass:
            return InertialType.subclass(*args_, **kwargs_)
        else:
            return InertialType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_origin(self): return self.origin
    def set_origin(self, origin): self.origin = origin
    def get_mass(self): return self.mass
    def set_mass(self, mass): self.mass = mass
    def get_inertia(self): return self.inertia
    def set_inertia(self, inertia): self.inertia = inertia
    def hasContent_(self):
        if (
            self.origin is not None or
            self.mass is not None or
            self.inertia is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InertialType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InertialType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InertialType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InertialType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='InertialType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.origin is not None:
            self.origin.export(outfile, level, namespace_, name_='origin', pretty_print=pretty_print)
        if self.mass is not None:
            self.mass.export(outfile, level, namespace_, name_='mass', pretty_print=pretty_print)
        if self.inertia is not None:
            self.inertia.export(outfile, level, namespace_, name_='inertia', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='InertialType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.origin is not None:
            showIndent(outfile, level)
            outfile.write('origin=model_.PoseType(\n')
            self.origin.exportLiteral(outfile, level, name_='origin')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.mass is not None:
            showIndent(outfile, level)
            outfile.write('mass=model_.MassType(\n')
            self.mass.exportLiteral(outfile, level, name_='mass')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.inertia is not None:
            showIndent(outfile, level)
            outfile.write('inertia=model_.InertiaType(\n')
            self.inertia.exportLiteral(outfile, level, name_='inertia')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'origin':
            obj_ = PoseType.factory()
            obj_.build(child_)
            self.origin = obj_
            obj_.original_tagname_ = 'origin'
        elif nodeName_ == 'mass':
            obj_ = MassType.factory()
            obj_.build(child_)
            self.mass = obj_
            obj_.original_tagname_ = 'mass'
        elif nodeName_ == 'inertia':
            obj_ = InertiaType.factory()
            obj_.build(child_)
            self.inertia = obj_
            obj_.original_tagname_ = 'inertia'
# end class InertialType


class BoxType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, size='0 0 0'):
        self.original_tagname_ = None
        self.size = _cast(None, size)
    def factory(*args_, **kwargs_):
        if BoxType.subclass:
            return BoxType.subclass(*args_, **kwargs_)
        else:
            return BoxType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BoxType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BoxType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BoxType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BoxType'):
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size=%s' % (self.gds_format_string(quote_attrib(self.size), input_name='size'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BoxType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='BoxType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            showIndent(outfile, level)
            outfile.write('size="%s",\n' % (self.size,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            self.size = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BoxType


class CylinderType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, length=None, radius=None):
        self.original_tagname_ = None
        self.length = _cast(float, length)
        self.radius = _cast(float, radius)
    def factory(*args_, **kwargs_):
        if CylinderType.subclass:
            return CylinderType.subclass(*args_, **kwargs_)
        else:
            return CylinderType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_length(self): return self.length
    def set_length(self, length): self.length = length
    def get_radius(self): return self.radius
    def set_radius(self, radius): self.radius = radius
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CylinderType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CylinderType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CylinderType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CylinderType'):
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length="%s"' % self.gds_format_double(self.length, input_name='length'))
        if self.radius is not None and 'radius' not in already_processed:
            already_processed.add('radius')
            outfile.write(' radius="%s"' % self.gds_format_double(self.radius, input_name='radius'))
    def exportChildren(self, outfile, level, namespace_='', name_='CylinderType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='CylinderType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            showIndent(outfile, level)
            outfile.write('length=%e,\n' % (self.length,))
        if self.radius is not None and 'radius' not in already_processed:
            already_processed.add('radius')
            showIndent(outfile, level)
            outfile.write('radius=%e,\n' % (self.radius,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            try:
                self.length = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (length): %s' % exp)
        value = find_attr_value_('radius', node)
        if value is not None and 'radius' not in already_processed:
            already_processed.add('radius')
            try:
                self.radius = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (radius): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CylinderType


class SphereType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, radius=None):
        self.original_tagname_ = None
        self.radius = _cast(float, radius)
    def factory(*args_, **kwargs_):
        if SphereType.subclass:
            return SphereType.subclass(*args_, **kwargs_)
        else:
            return SphereType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_radius(self): return self.radius
    def set_radius(self, radius): self.radius = radius
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SphereType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SphereType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SphereType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SphereType'):
        if self.radius is not None and 'radius' not in already_processed:
            already_processed.add('radius')
            outfile.write(' radius="%s"' % self.gds_format_double(self.radius, input_name='radius'))
    def exportChildren(self, outfile, level, namespace_='', name_='SphereType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='SphereType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.radius is not None and 'radius' not in already_processed:
            already_processed.add('radius')
            showIndent(outfile, level)
            outfile.write('radius=%e,\n' % (self.radius,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('radius', node)
        if value is not None and 'radius' not in already_processed:
            already_processed.add('radius')
            try:
                self.radius = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (radius): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SphereType


class MeshType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, scale='1 1 1', filename=None):
        self.original_tagname_ = None
        self.scale = _cast(None, scale)
        self.filename = _cast(None, filename)
    def factory(*args_, **kwargs_):
        if MeshType.subclass:
            return MeshType.subclass(*args_, **kwargs_)
        else:
            return MeshType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_scale(self): return self.scale
    def set_scale(self, scale): self.scale = scale
    def get_filename(self): return self.filename
    def set_filename(self, filename): self.filename = filename
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MeshType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeshType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MeshType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MeshType'):
        if self.scale is not None and 'scale' not in already_processed:
            already_processed.add('scale')
            outfile.write(' scale=%s' % (self.gds_format_string(quote_attrib(self.scale), input_name='scale'), ))
        if self.filename is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            outfile.write(' filename=%s' % (self.gds_format_string(quote_attrib(self.filename), input_name='filename'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MeshType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='MeshType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.scale is not None and 'scale' not in already_processed:
            already_processed.add('scale')
            showIndent(outfile, level)
            outfile.write('scale="%s",\n' % (self.scale,))
        if self.filename is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            showIndent(outfile, level)
            outfile.write('filename="%s",\n' % (self.filename,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('scale', node)
        if value is not None and 'scale' not in already_processed:
            already_processed.add('scale')
            self.scale = value
        value = find_attr_value_('filename', node)
        if value is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            self.filename = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MeshType


class GeometryType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, box=None, cylinder=None, sphere=None, mesh=None):
        self.original_tagname_ = None
        self.box = box
        self.cylinder = cylinder
        self.sphere = sphere
        self.mesh = mesh
    def factory(*args_, **kwargs_):
        if GeometryType.subclass:
            return GeometryType.subclass(*args_, **kwargs_)
        else:
            return GeometryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_box(self): return self.box
    def set_box(self, box): self.box = box
    def get_cylinder(self): return self.cylinder
    def set_cylinder(self, cylinder): self.cylinder = cylinder
    def get_sphere(self): return self.sphere
    def set_sphere(self, sphere): self.sphere = sphere
    def get_mesh(self): return self.mesh
    def set_mesh(self, mesh): self.mesh = mesh
    def hasContent_(self):
        if (
            self.box is not None or
            self.cylinder is not None or
            self.sphere is not None or
            self.mesh is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GeometryType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeometryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GeometryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GeometryType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GeometryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.box is not None:
            self.box.export(outfile, level, namespace_, name_='box', pretty_print=pretty_print)
        if self.cylinder is not None:
            self.cylinder.export(outfile, level, namespace_, name_='cylinder', pretty_print=pretty_print)
        if self.sphere is not None:
            self.sphere.export(outfile, level, namespace_, name_='sphere', pretty_print=pretty_print)
        if self.mesh is not None:
            self.mesh.export(outfile, level, namespace_, name_='mesh', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='GeometryType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.box is not None:
            showIndent(outfile, level)
            outfile.write('box=model_.BoxType(\n')
            self.box.exportLiteral(outfile, level, name_='box')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cylinder is not None:
            showIndent(outfile, level)
            outfile.write('cylinder=model_.CylinderType(\n')
            self.cylinder.exportLiteral(outfile, level, name_='cylinder')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sphere is not None:
            showIndent(outfile, level)
            outfile.write('sphere=model_.SphereType(\n')
            self.sphere.exportLiteral(outfile, level, name_='sphere')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.mesh is not None:
            showIndent(outfile, level)
            outfile.write('mesh=model_.MeshType(\n')
            self.mesh.exportLiteral(outfile, level, name_='mesh')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'box':
            obj_ = BoxType.factory()
            obj_.build(child_)
            self.box = obj_
            obj_.original_tagname_ = 'box'
        elif nodeName_ == 'cylinder':
            obj_ = CylinderType.factory()
            obj_.build(child_)
            self.cylinder = obj_
            obj_.original_tagname_ = 'cylinder'
        elif nodeName_ == 'sphere':
            obj_ = SphereType.factory()
            obj_.build(child_)
            self.sphere = obj_
            obj_.original_tagname_ = 'sphere'
        elif nodeName_ == 'mesh':
            obj_ = MeshType.factory()
            obj_.build(child_)
            self.mesh = obj_
            obj_.original_tagname_ = 'mesh'
# end class GeometryType


class TextureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, filename=None):
        self.original_tagname_ = None
        self.filename = _cast(None, filename)
    def factory(*args_, **kwargs_):
        if TextureType.subclass:
            return TextureType.subclass(*args_, **kwargs_)
        else:
            return TextureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_filename(self): return self.filename
    def set_filename(self, filename): self.filename = filename
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TextureType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TextureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TextureType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TextureType'):
        if self.filename is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            outfile.write(' filename=%s' % (self.gds_format_string(quote_attrib(self.filename), input_name='filename'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TextureType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='TextureType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.filename is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            showIndent(outfile, level)
            outfile.write('filename="%s",\n' % (self.filename,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('filename', node)
        if value is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            self.filename = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TextureType


class MaterialType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, color=None, texture=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.color = color
        self.texture = texture
    def factory(*args_, **kwargs_):
        if MaterialType.subclass:
            return MaterialType.subclass(*args_, **kwargs_)
        else:
            return MaterialType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_color(self): return self.color
    def set_color(self, color): self.color = color
    def get_texture(self): return self.texture
    def set_texture(self, texture): self.texture = texture
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            self.color is not None or
            self.texture is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MaterialType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MaterialType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MaterialType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MaterialType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MaterialType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.color is not None:
            self.color.export(outfile, level, namespace_, name_='color', pretty_print=pretty_print)
        if self.texture is not None:
            self.texture.export(outfile, level, namespace_, name_='texture', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MaterialType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.color is not None:
            showIndent(outfile, level)
            outfile.write('color=model_.ColorType(\n')
            self.color.exportLiteral(outfile, level, name_='color')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.texture is not None:
            showIndent(outfile, level)
            outfile.write('texture=model_.TextureType(\n')
            self.texture.exportLiteral(outfile, level, name_='texture')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'color':
            obj_ = ColorType.factory()
            obj_.build(child_)
            self.color = obj_
            obj_.original_tagname_ = 'color'
        elif nodeName_ == 'texture':
            obj_ = TextureType.factory()
            obj_.build(child_)
            self.texture = obj_
            obj_.original_tagname_ = 'texture'
# end class MaterialType


class VisualType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, origin=None, geometry=None, material=None):
        self.original_tagname_ = None
        self.origin = origin
        self.geometry = geometry
        self.material = material
    def factory(*args_, **kwargs_):
        if VisualType.subclass:
            return VisualType.subclass(*args_, **kwargs_)
        else:
            return VisualType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_origin(self): return self.origin
    def set_origin(self, origin): self.origin = origin
    def get_geometry(self): return self.geometry
    def set_geometry(self, geometry): self.geometry = geometry
    def get_material(self): return self.material
    def set_material(self, material): self.material = material
    def hasContent_(self):
        if (
            self.origin is not None or
            self.geometry is not None or
            self.material is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VisualType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VisualType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VisualType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VisualType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VisualType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.origin is not None:
            self.origin.export(outfile, level, namespace_, name_='origin', pretty_print=pretty_print)
        if self.geometry is not None:
            self.geometry.export(outfile, level, namespace_, name_='geometry', pretty_print=pretty_print)
        if self.material is not None:
            self.material.export(outfile, level, namespace_, name_='material', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VisualType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.origin is not None:
            showIndent(outfile, level)
            outfile.write('origin=model_.PoseType(\n')
            self.origin.exportLiteral(outfile, level, name_='origin')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.geometry is not None:
            showIndent(outfile, level)
            outfile.write('geometry=model_.GeometryType(\n')
            self.geometry.exportLiteral(outfile, level, name_='geometry')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.material is not None:
            showIndent(outfile, level)
            outfile.write('material=model_.MaterialType(\n')
            self.material.exportLiteral(outfile, level, name_='material')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'origin':
            obj_ = PoseType.factory()
            obj_.build(child_)
            self.origin = obj_
            obj_.original_tagname_ = 'origin'
        elif nodeName_ == 'geometry':
            obj_ = GeometryType.factory()
            obj_.build(child_)
            self.geometry = obj_
            obj_.original_tagname_ = 'geometry'
        elif nodeName_ == 'material':
            obj_ = MaterialType.factory()
            obj_.build(child_)
            self.material = obj_
            obj_.original_tagname_ = 'material'
# end class VisualType


class ContactType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mu=0, kp=0, kd=0):
        self.original_tagname_ = None
        self.mu = _cast(float, mu)
        self.kp = _cast(float, kp)
        self.kd = _cast(float, kd)
    def factory(*args_, **kwargs_):
        if ContactType.subclass:
            return ContactType.subclass(*args_, **kwargs_)
        else:
            return ContactType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mu(self): return self.mu
    def set_mu(self, mu): self.mu = mu
    def get_kp(self): return self.kp
    def set_kp(self, kp): self.kp = kp
    def get_kd(self): return self.kd
    def set_kd(self, kd): self.kd = kd
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ContactType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContactType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ContactType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContactType'):
        if self.mu is not None and 'mu' not in already_processed:
            already_processed.add('mu')
            outfile.write(' mu="%s"' % self.gds_format_double(self.mu, input_name='mu'))
        if self.kp is not None and 'kp' not in already_processed:
            already_processed.add('kp')
            outfile.write(' kp="%s"' % self.gds_format_double(self.kp, input_name='kp'))
        if self.kd is not None and 'kd' not in already_processed:
            already_processed.add('kd')
            outfile.write(' kd="%s"' % self.gds_format_double(self.kd, input_name='kd'))
    def exportChildren(self, outfile, level, namespace_='', name_='ContactType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ContactType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.mu is not None and 'mu' not in already_processed:
            already_processed.add('mu')
            showIndent(outfile, level)
            outfile.write('mu=%e,\n' % (self.mu,))
        if self.kp is not None and 'kp' not in already_processed:
            already_processed.add('kp')
            showIndent(outfile, level)
            outfile.write('kp=%e,\n' % (self.kp,))
        if self.kd is not None and 'kd' not in already_processed:
            already_processed.add('kd')
            showIndent(outfile, level)
            outfile.write('kd=%e,\n' % (self.kd,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mu', node)
        if value is not None and 'mu' not in already_processed:
            already_processed.add('mu')
            try:
                self.mu = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (mu): %s' % exp)
        value = find_attr_value_('kp', node)
        if value is not None and 'kp' not in already_processed:
            already_processed.add('kp')
            try:
                self.kp = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (kp): %s' % exp)
        value = find_attr_value_('kd', node)
        if value is not None and 'kd' not in already_processed:
            already_processed.add('kd')
            try:
                self.kd = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (kd): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ContactType


class CollisionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, origin=None, geometry=None, contact_coefficients=None, verbose=None):
        self.original_tagname_ = None
        self.origin = origin
        self.geometry = geometry
        self.contact_coefficients = contact_coefficients
        self.verbose = verbose
    def factory(*args_, **kwargs_):
        if CollisionType.subclass:
            return CollisionType.subclass(*args_, **kwargs_)
        else:
            return CollisionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_origin(self): return self.origin
    def set_origin(self, origin): self.origin = origin
    def get_geometry(self): return self.geometry
    def set_geometry(self, geometry): self.geometry = geometry
    def get_contact_coefficients(self): return self.contact_coefficients
    def set_contact_coefficients(self, contact_coefficients): self.contact_coefficients = contact_coefficients
    def get_verbose(self): return self.verbose
    def set_verbose(self, verbose): self.verbose = verbose
    def hasContent_(self):
        if (
            self.origin is not None or
            self.geometry is not None or
            self.contact_coefficients is not None or
            self.verbose is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CollisionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CollisionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CollisionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CollisionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CollisionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.origin is not None:
            self.origin.export(outfile, level, namespace_, name_='origin', pretty_print=pretty_print)
        if self.geometry is not None:
            self.geometry.export(outfile, level, namespace_, name_='geometry', pretty_print=pretty_print)
        if self.contact_coefficients is not None:
            self.contact_coefficients.export(outfile, level, namespace_, name_='contact_coefficients', pretty_print=pretty_print)
        if self.verbose is not None:
            self.verbose.export(outfile, level, namespace_, name_='verbose', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CollisionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.origin is not None:
            showIndent(outfile, level)
            outfile.write('origin=model_.PoseType(\n')
            self.origin.exportLiteral(outfile, level, name_='origin')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.geometry is not None:
            showIndent(outfile, level)
            outfile.write('geometry=model_.GeometryType(\n')
            self.geometry.exportLiteral(outfile, level, name_='geometry')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.contact_coefficients is not None:
            showIndent(outfile, level)
            outfile.write('contact_coefficients=model_.ContactType(\n')
            self.contact_coefficients.exportLiteral(outfile, level, name_='contact_coefficients')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.verbose is not None:
            showIndent(outfile, level)
            outfile.write('verbose=model_.VerboseType(\n')
            self.verbose.exportLiteral(outfile, level, name_='verbose')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'origin':
            obj_ = PoseType.factory()
            obj_.build(child_)
            self.origin = obj_
            obj_.original_tagname_ = 'origin'
        elif nodeName_ == 'geometry':
            obj_ = GeometryType.factory()
            obj_.build(child_)
            self.geometry = obj_
            obj_.original_tagname_ = 'geometry'
        elif nodeName_ == 'contact_coefficients':
            obj_ = ContactType.factory()
            obj_.build(child_)
            self.contact_coefficients = obj_
            obj_.original_tagname_ = 'contact_coefficients'
        elif nodeName_ == 'verbose':
            obj_ = VerboseType.factory()
            obj_.build(child_)
            self.verbose = obj_
            obj_.original_tagname_ = 'verbose'
# end class CollisionType


class LinkType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, origin=None, inertial=None, visual=None, collision=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.origin = origin
        self.inertial = inertial
        if visual is None:
            self.visual = []
        else:
            self.visual = visual
        if collision is None:
            self.collision = []
        else:
            self.collision = collision
    def factory(*args_, **kwargs_):
        if LinkType.subclass:
            return LinkType.subclass(*args_, **kwargs_)
        else:
            return LinkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_origin(self): return self.origin
    def set_origin(self, origin): self.origin = origin
    def get_inertial(self): return self.inertial
    def set_inertial(self, inertial): self.inertial = inertial
    def get_visual(self): return self.visual
    def set_visual(self, visual): self.visual = visual
    def add_visual(self, value): self.visual.append(value)
    def insert_visual_at(self, index, value): self.visual.insert(index, value)
    def replace_visual_at(self, index, value): self.visual[index] = value
    def get_collision(self): return self.collision
    def set_collision(self, collision): self.collision = collision
    def add_collision(self, value): self.collision.append(value)
    def insert_collision_at(self, index, value): self.collision.insert(index, value)
    def replace_collision_at(self, index, value): self.collision[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            self.origin is not None or
            self.inertial is not None or
            self.visual or
            self.collision
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LinkType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LinkType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinkType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LinkType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.origin is not None:
            self.origin.export(outfile, level, namespace_, name_='origin', pretty_print=pretty_print)
        if self.inertial is not None:
            self.inertial.export(outfile, level, namespace_, name_='inertial', pretty_print=pretty_print)
        for visual_ in self.visual:
            visual_.export(outfile, level, namespace_, name_='visual', pretty_print=pretty_print)
        for collision_ in self.collision:
            collision_.export(outfile, level, namespace_, name_='collision', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LinkType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.origin is not None:
            showIndent(outfile, level)
            outfile.write('origin=model_.PoseType(\n')
            self.origin.exportLiteral(outfile, level, name_='origin')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.inertial is not None:
            showIndent(outfile, level)
            outfile.write('inertial=model_.InertialType(\n')
            self.inertial.exportLiteral(outfile, level, name_='inertial')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('visual=[\n')
        level += 1
        for visual_ in self.visual:
            showIndent(outfile, level)
            outfile.write('model_.VisualType(\n')
            visual_.exportLiteral(outfile, level, name_='VisualType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('collision=[\n')
        level += 1
        for collision_ in self.collision:
            showIndent(outfile, level)
            outfile.write('model_.CollisionType(\n')
            collision_.exportLiteral(outfile, level, name_='CollisionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'origin':
            obj_ = PoseType.factory()
            obj_.build(child_)
            self.origin = obj_
            obj_.original_tagname_ = 'origin'
        elif nodeName_ == 'inertial':
            obj_ = InertialType.factory()
            obj_.build(child_)
            self.inertial = obj_
            obj_.original_tagname_ = 'inertial'
        elif nodeName_ == 'visual':
            obj_ = VisualType.factory()
            obj_.build(child_)
            self.visual.append(obj_)
            obj_.original_tagname_ = 'visual'
        elif nodeName_ == 'collision':
            obj_ = CollisionType.factory()
            obj_.build(child_)
            self.collision.append(obj_)
            obj_.original_tagname_ = 'collision'
# end class LinkType


class ParentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, link=None):
        self.original_tagname_ = None
        self.link = _cast(None, link)
    def factory(*args_, **kwargs_):
        if ParentType.subclass:
            return ParentType.subclass(*args_, **kwargs_)
        else:
            return ParentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_link(self): return self.link
    def set_link(self, link): self.link = link
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ParentType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ParentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ParentType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ParentType'):
        if self.link is not None and 'link' not in already_processed:
            already_processed.add('link')
            outfile.write(' link=%s' % (self.gds_format_string(quote_attrib(self.link), input_name='link'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ParentType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ParentType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.link is not None and 'link' not in already_processed:
            already_processed.add('link')
            showIndent(outfile, level)
            outfile.write('link="%s",\n' % (self.link,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('link', node)
        if value is not None and 'link' not in already_processed:
            already_processed.add('link')
            self.link = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ParentType


class ChildType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, link=None):
        self.original_tagname_ = None
        self.link = _cast(None, link)
    def factory(*args_, **kwargs_):
        if ChildType.subclass:
            return ChildType.subclass(*args_, **kwargs_)
        else:
            return ChildType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_link(self): return self.link
    def set_link(self, link): self.link = link
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ChildType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChildType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ChildType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChildType'):
        if self.link is not None and 'link' not in already_processed:
            already_processed.add('link')
            outfile.write(' link=%s' % (self.gds_format_string(quote_attrib(self.link), input_name='link'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ChildType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ChildType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.link is not None and 'link' not in already_processed:
            already_processed.add('link')
            showIndent(outfile, level)
            outfile.write('link="%s",\n' % (self.link,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('link', node)
        if value is not None and 'link' not in already_processed:
            already_processed.add('link')
            self.link = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ChildType


class AxisType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, xyz='1 0 0'):
        self.original_tagname_ = None
        self.xyz = _cast(None, xyz)
    def factory(*args_, **kwargs_):
        if AxisType.subclass:
            return AxisType.subclass(*args_, **kwargs_)
        else:
            return AxisType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xyz(self): return self.xyz
    def set_xyz(self, xyz): self.xyz = xyz
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AxisType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AxisType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AxisType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AxisType'):
        if self.xyz is not None and 'xyz' not in already_processed:
            already_processed.add('xyz')
            outfile.write(' xyz=%s' % (self.gds_format_string(quote_attrib(self.xyz), input_name='xyz'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AxisType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='AxisType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.xyz is not None and 'xyz' not in already_processed:
            already_processed.add('xyz')
            showIndent(outfile, level)
            outfile.write('xyz="%s",\n' % (self.xyz,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xyz', node)
        if value is not None and 'xyz' not in already_processed:
            already_processed.add('xyz')
            self.xyz = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AxisType


class CalibrationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, reference_position=None, falling=None, rising=None):
        self.original_tagname_ = None
        self.reference_position = _cast(float, reference_position)
        self.falling = _cast(float, falling)
        self.rising = _cast(float, rising)
    def factory(*args_, **kwargs_):
        if CalibrationType.subclass:
            return CalibrationType.subclass(*args_, **kwargs_)
        else:
            return CalibrationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reference_position(self): return self.reference_position
    def set_reference_position(self, reference_position): self.reference_position = reference_position
    def get_falling(self): return self.falling
    def set_falling(self, falling): self.falling = falling
    def get_rising(self): return self.rising
    def set_rising(self, rising): self.rising = rising
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CalibrationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CalibrationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CalibrationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CalibrationType'):
        if self.reference_position is not None and 'reference_position' not in already_processed:
            already_processed.add('reference_position')
            outfile.write(' reference_position="%s"' % self.gds_format_double(self.reference_position, input_name='reference_position'))
        if self.falling is not None and 'falling' not in already_processed:
            already_processed.add('falling')
            outfile.write(' falling="%s"' % self.gds_format_double(self.falling, input_name='falling'))
        if self.rising is not None and 'rising' not in already_processed:
            already_processed.add('rising')
            outfile.write(' rising="%s"' % self.gds_format_double(self.rising, input_name='rising'))
    def exportChildren(self, outfile, level, namespace_='', name_='CalibrationType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='CalibrationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.reference_position is not None and 'reference_position' not in already_processed:
            already_processed.add('reference_position')
            showIndent(outfile, level)
            outfile.write('reference_position=%e,\n' % (self.reference_position,))
        if self.falling is not None and 'falling' not in already_processed:
            already_processed.add('falling')
            showIndent(outfile, level)
            outfile.write('falling=%e,\n' % (self.falling,))
        if self.rising is not None and 'rising' not in already_processed:
            already_processed.add('rising')
            showIndent(outfile, level)
            outfile.write('rising=%e,\n' % (self.rising,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('reference_position', node)
        if value is not None and 'reference_position' not in already_processed:
            already_processed.add('reference_position')
            try:
                self.reference_position = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (reference_position): %s' % exp)
        value = find_attr_value_('falling', node)
        if value is not None and 'falling' not in already_processed:
            already_processed.add('falling')
            try:
                self.falling = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (falling): %s' % exp)
        value = find_attr_value_('rising', node)
        if value is not None and 'rising' not in already_processed:
            already_processed.add('rising')
            try:
                self.rising = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (rising): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CalibrationType


class DynamicsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, damping=0, friction=0):
        self.original_tagname_ = None
        self.damping = _cast(float, damping)
        self.friction = _cast(float, friction)
    def factory(*args_, **kwargs_):
        if DynamicsType.subclass:
            return DynamicsType.subclass(*args_, **kwargs_)
        else:
            return DynamicsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_damping(self): return self.damping
    def set_damping(self, damping): self.damping = damping
    def get_friction(self): return self.friction
    def set_friction(self, friction): self.friction = friction
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DynamicsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DynamicsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DynamicsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DynamicsType'):
        if self.damping is not None and 'damping' not in already_processed:
            already_processed.add('damping')
            outfile.write(' damping="%s"' % self.gds_format_double(self.damping, input_name='damping'))
        if self.friction is not None and 'friction' not in already_processed:
            already_processed.add('friction')
            outfile.write(' friction="%s"' % self.gds_format_double(self.friction, input_name='friction'))
    def exportChildren(self, outfile, level, namespace_='', name_='DynamicsType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='DynamicsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.damping is not None and 'damping' not in already_processed:
            already_processed.add('damping')
            showIndent(outfile, level)
            outfile.write('damping=%e,\n' % (self.damping,))
        if self.friction is not None and 'friction' not in already_processed:
            already_processed.add('friction')
            showIndent(outfile, level)
            outfile.write('friction=%e,\n' % (self.friction,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('damping', node)
        if value is not None and 'damping' not in already_processed:
            already_processed.add('damping')
            try:
                self.damping = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (damping): %s' % exp)
        value = find_attr_value_('friction', node)
        if value is not None and 'friction' not in already_processed:
            already_processed.add('friction')
            try:
                self.friction = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (friction): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DynamicsType


class LimitType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, upper=0, lower=0, effort=0, velocity=0):
        self.original_tagname_ = None
        self.upper = _cast(float, upper)
        self.lower = _cast(float, lower)
        self.effort = _cast(float, effort)
        self.velocity = _cast(float, velocity)
    def factory(*args_, **kwargs_):
        if LimitType.subclass:
            return LimitType.subclass(*args_, **kwargs_)
        else:
            return LimitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_upper(self): return self.upper
    def set_upper(self, upper): self.upper = upper
    def get_lower(self): return self.lower
    def set_lower(self, lower): self.lower = lower
    def get_effort(self): return self.effort
    def set_effort(self, effort): self.effort = effort
    def get_velocity(self): return self.velocity
    def set_velocity(self, velocity): self.velocity = velocity
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LimitType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LimitType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LimitType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LimitType'):
        if self.upper is not None and 'upper' not in already_processed:
            already_processed.add('upper')
            outfile.write(' upper="%s"' % self.gds_format_double(self.upper, input_name='upper'))
        if self.lower is not None and 'lower' not in already_processed:
            already_processed.add('lower')
            outfile.write(' lower="%s"' % self.gds_format_double(self.lower, input_name='lower'))
        if self.effort is not None and 'effort' not in already_processed:
            already_processed.add('effort')
            outfile.write(' effort="%s"' % self.gds_format_double(self.effort, input_name='effort'))
        if self.velocity is not None and 'velocity' not in already_processed:
            already_processed.add('velocity')
            outfile.write(' velocity="%s"' % self.gds_format_double(self.velocity, input_name='velocity'))
    def exportChildren(self, outfile, level, namespace_='', name_='LimitType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='LimitType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.upper is not None and 'upper' not in already_processed:
            already_processed.add('upper')
            showIndent(outfile, level)
            outfile.write('upper=%e,\n' % (self.upper,))
        if self.lower is not None and 'lower' not in already_processed:
            already_processed.add('lower')
            showIndent(outfile, level)
            outfile.write('lower=%e,\n' % (self.lower,))
        if self.effort is not None and 'effort' not in already_processed:
            already_processed.add('effort')
            showIndent(outfile, level)
            outfile.write('effort=%e,\n' % (self.effort,))
        if self.velocity is not None and 'velocity' not in already_processed:
            already_processed.add('velocity')
            showIndent(outfile, level)
            outfile.write('velocity=%e,\n' % (self.velocity,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('upper', node)
        if value is not None and 'upper' not in already_processed:
            already_processed.add('upper')
            try:
                self.upper = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (upper): %s' % exp)
        value = find_attr_value_('lower', node)
        if value is not None and 'lower' not in already_processed:
            already_processed.add('lower')
            try:
                self.lower = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (lower): %s' % exp)
        value = find_attr_value_('effort', node)
        if value is not None and 'effort' not in already_processed:
            already_processed.add('effort')
            try:
                self.effort = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (effort): %s' % exp)
        value = find_attr_value_('velocity', node)
        if value is not None and 'velocity' not in already_processed:
            already_processed.add('velocity')
            try:
                self.velocity = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (velocity): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LimitType


class SafetyControllerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, soft_upper_limit=0, k_position=0, soft_lower_limit=0, k_velocity=None):
        self.original_tagname_ = None
        self.soft_upper_limit = _cast(float, soft_upper_limit)
        self.k_position = _cast(float, k_position)
        self.soft_lower_limit = _cast(float, soft_lower_limit)
        self.k_velocity = _cast(float, k_velocity)
    def factory(*args_, **kwargs_):
        if SafetyControllerType.subclass:
            return SafetyControllerType.subclass(*args_, **kwargs_)
        else:
            return SafetyControllerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_soft_upper_limit(self): return self.soft_upper_limit
    def set_soft_upper_limit(self, soft_upper_limit): self.soft_upper_limit = soft_upper_limit
    def get_k_position(self): return self.k_position
    def set_k_position(self, k_position): self.k_position = k_position
    def get_soft_lower_limit(self): return self.soft_lower_limit
    def set_soft_lower_limit(self, soft_lower_limit): self.soft_lower_limit = soft_lower_limit
    def get_k_velocity(self): return self.k_velocity
    def set_k_velocity(self, k_velocity): self.k_velocity = k_velocity
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SafetyControllerType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SafetyControllerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SafetyControllerType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SafetyControllerType'):
        if self.soft_upper_limit is not None and 'soft_upper_limit' not in already_processed:
            already_processed.add('soft_upper_limit')
            outfile.write(' soft_upper_limit="%s"' % self.gds_format_double(self.soft_upper_limit, input_name='soft_upper_limit'))
        if self.k_position is not None and 'k_position' not in already_processed:
            already_processed.add('k_position')
            outfile.write(' k_position="%s"' % self.gds_format_double(self.k_position, input_name='k_position'))
        if self.soft_lower_limit is not None and 'soft_lower_limit' not in already_processed:
            already_processed.add('soft_lower_limit')
            outfile.write(' soft_lower_limit="%s"' % self.gds_format_double(self.soft_lower_limit, input_name='soft_lower_limit'))
        if self.k_velocity is not None and 'k_velocity' not in already_processed:
            already_processed.add('k_velocity')
            outfile.write(' k_velocity="%s"' % self.gds_format_double(self.k_velocity, input_name='k_velocity'))
    def exportChildren(self, outfile, level, namespace_='', name_='SafetyControllerType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='SafetyControllerType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.soft_upper_limit is not None and 'soft_upper_limit' not in already_processed:
            already_processed.add('soft_upper_limit')
            showIndent(outfile, level)
            outfile.write('soft_upper_limit=%e,\n' % (self.soft_upper_limit,))
        if self.k_position is not None and 'k_position' not in already_processed:
            already_processed.add('k_position')
            showIndent(outfile, level)
            outfile.write('k_position=%e,\n' % (self.k_position,))
        if self.soft_lower_limit is not None and 'soft_lower_limit' not in already_processed:
            already_processed.add('soft_lower_limit')
            showIndent(outfile, level)
            outfile.write('soft_lower_limit=%e,\n' % (self.soft_lower_limit,))
        if self.k_velocity is not None and 'k_velocity' not in already_processed:
            already_processed.add('k_velocity')
            showIndent(outfile, level)
            outfile.write('k_velocity=%e,\n' % (self.k_velocity,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('soft_upper_limit', node)
        if value is not None and 'soft_upper_limit' not in already_processed:
            already_processed.add('soft_upper_limit')
            try:
                self.soft_upper_limit = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (soft_upper_limit): %s' % exp)
        value = find_attr_value_('k_position', node)
        if value is not None and 'k_position' not in already_processed:
            already_processed.add('k_position')
            try:
                self.k_position = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (k_position): %s' % exp)
        value = find_attr_value_('soft_lower_limit', node)
        if value is not None and 'soft_lower_limit' not in already_processed:
            already_processed.add('soft_lower_limit')
            try:
                self.soft_lower_limit = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (soft_lower_limit): %s' % exp)
        value = find_attr_value_('k_velocity', node)
        if value is not None and 'k_velocity' not in already_processed:
            already_processed.add('k_velocity')
            try:
                self.k_velocity = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (k_velocity): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SafetyControllerType


class MimicType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, joint=None, offset=0, multiplier=1):
        self.original_tagname_ = None
        self.joint = _cast(None, joint)
        self.offset = _cast(float, offset)
        self.multiplier = _cast(float, multiplier)
    def factory(*args_, **kwargs_):
        if MimicType.subclass:
            return MimicType.subclass(*args_, **kwargs_)
        else:
            return MimicType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_joint(self): return self.joint
    def set_joint(self, joint): self.joint = joint
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def get_multiplier(self): return self.multiplier
    def set_multiplier(self, multiplier): self.multiplier = multiplier
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MimicType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MimicType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MimicType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MimicType'):
        if self.joint is not None and 'joint' not in already_processed:
            already_processed.add('joint')
            outfile.write(' joint=%s' % (self.gds_format_string(quote_attrib(self.joint), input_name='joint'), ))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_double(self.offset, input_name='offset'))
        if self.multiplier is not None and 'multiplier' not in already_processed:
            already_processed.add('multiplier')
            outfile.write(' multiplier="%s"' % self.gds_format_double(self.multiplier, input_name='multiplier'))
    def exportChildren(self, outfile, level, namespace_='', name_='MimicType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='MimicType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.joint is not None and 'joint' not in already_processed:
            already_processed.add('joint')
            showIndent(outfile, level)
            outfile.write('joint="%s",\n' % (self.joint,))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            showIndent(outfile, level)
            outfile.write('offset=%e,\n' % (self.offset,))
        if self.multiplier is not None and 'multiplier' not in already_processed:
            already_processed.add('multiplier')
            showIndent(outfile, level)
            outfile.write('multiplier=%e,\n' % (self.multiplier,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('joint', node)
        if value is not None and 'joint' not in already_processed:
            already_processed.add('joint')
            self.joint = value
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (offset): %s' % exp)
        value = find_attr_value_('multiplier', node)
        if value is not None and 'multiplier' not in already_processed:
            already_processed.add('multiplier')
            try:
                self.multiplier = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (multiplier): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MimicType


class JointType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, name=None, origin=None, parent=None, child=None, axis=None, calibration=None, dynamics=None, limit=None, safety_controller=None, mimic=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.name = _cast(None, name)
        self.origin = origin
        self.parent = parent
        self.child = child
        self.axis = axis
        self.calibration = calibration
        self.dynamics = dynamics
        self.limit = limit
        self.safety_controller = safety_controller
        self.mimic = mimic
    def factory(*args_, **kwargs_):
        if JointType.subclass:
            return JointType.subclass(*args_, **kwargs_)
        else:
            return JointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_origin(self): return self.origin
    def set_origin(self, origin): self.origin = origin
    def get_parent(self): return self.parent
    def set_parent(self, parent): self.parent = parent
    def get_child(self): return self.child
    def set_child(self, child): self.child = child
    def get_axis(self): return self.axis
    def set_axis(self, axis): self.axis = axis
    def get_calibration(self): return self.calibration
    def set_calibration(self, calibration): self.calibration = calibration
    def get_dynamics(self): return self.dynamics
    def set_dynamics(self, dynamics): self.dynamics = dynamics
    def get_limit(self): return self.limit
    def set_limit(self, limit): self.limit = limit
    def get_safety_controller(self): return self.safety_controller
    def set_safety_controller(self, safety_controller): self.safety_controller = safety_controller
    def get_mimic(self): return self.mimic
    def set_mimic(self, mimic): self.mimic = mimic
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            self.origin is not None or
            self.parent is not None or
            self.child is not None or
            self.axis is not None or
            self.calibration is not None or
            self.dynamics is not None or
            self.limit is not None or
            self.safety_controller is not None or
            self.mimic is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='JointType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='JointType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='JointType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='JointType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_), input_name='type'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='JointType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.origin is not None:
            self.origin.export(outfile, level, namespace_, name_='origin', pretty_print=pretty_print)
        if self.parent is not None:
            self.parent.export(outfile, level, namespace_, name_='parent', pretty_print=pretty_print)
        if self.child is not None:
            self.child.export(outfile, level, namespace_, name_='child', pretty_print=pretty_print)
        if self.axis is not None:
            self.axis.export(outfile, level, namespace_, name_='axis', pretty_print=pretty_print)
        if self.calibration is not None:
            self.calibration.export(outfile, level, namespace_, name_='calibration', pretty_print=pretty_print)
        if self.dynamics is not None:
            self.dynamics.export(outfile, level, namespace_, name_='dynamics', pretty_print=pretty_print)
        if self.limit is not None:
            self.limit.export(outfile, level, namespace_, name_='limit', pretty_print=pretty_print)
        if self.safety_controller is not None:
            self.safety_controller.export(outfile, level, namespace_, name_='safety_controller', pretty_print=pretty_print)
        if self.mimic is not None:
            self.mimic.export(outfile, level, namespace_, name_='mimic', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='JointType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.origin is not None:
            showIndent(outfile, level)
            outfile.write('origin=model_.PoseType(\n')
            self.origin.exportLiteral(outfile, level, name_='origin')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.parent is not None:
            showIndent(outfile, level)
            outfile.write('parent=model_.ParentType(\n')
            self.parent.exportLiteral(outfile, level, name_='parent')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.child is not None:
            showIndent(outfile, level)
            outfile.write('child=model_.ChildType(\n')
            self.child.exportLiteral(outfile, level, name_='child')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.axis is not None:
            showIndent(outfile, level)
            outfile.write('axis=model_.AxisType(\n')
            self.axis.exportLiteral(outfile, level, name_='axis')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.calibration is not None:
            showIndent(outfile, level)
            outfile.write('calibration=model_.CalibrationType(\n')
            self.calibration.exportLiteral(outfile, level, name_='calibration')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dynamics is not None:
            showIndent(outfile, level)
            outfile.write('dynamics=model_.DynamicsType(\n')
            self.dynamics.exportLiteral(outfile, level, name_='dynamics')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.limit is not None:
            showIndent(outfile, level)
            outfile.write('limit=model_.LimitType(\n')
            self.limit.exportLiteral(outfile, level, name_='limit')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.safety_controller is not None:
            showIndent(outfile, level)
            outfile.write('safety_controller=model_.SafetyControllerType(\n')
            self.safety_controller.exportLiteral(outfile, level, name_='safety_controller')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.mimic is not None:
            showIndent(outfile, level)
            outfile.write('mimic=model_.MimicType(\n')
            self.mimic.exportLiteral(outfile, level, name_='mimic')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'origin':
            obj_ = PoseType.factory()
            obj_.build(child_)
            self.origin = obj_
            obj_.original_tagname_ = 'origin'
        elif nodeName_ == 'parent':
            obj_ = ParentType.factory()
            obj_.build(child_)
            self.parent = obj_
            obj_.original_tagname_ = 'parent'
        elif nodeName_ == 'child':
            obj_ = ChildType.factory()
            obj_.build(child_)
            self.child = obj_
            obj_.original_tagname_ = 'child'
        elif nodeName_ == 'axis':
            obj_ = AxisType.factory()
            obj_.build(child_)
            self.axis = obj_
            obj_.original_tagname_ = 'axis'
        elif nodeName_ == 'calibration':
            obj_ = CalibrationType.factory()
            obj_.build(child_)
            self.calibration = obj_
            obj_.original_tagname_ = 'calibration'
        elif nodeName_ == 'dynamics':
            obj_ = DynamicsType.factory()
            obj_.build(child_)
            self.dynamics = obj_
            obj_.original_tagname_ = 'dynamics'
        elif nodeName_ == 'limit':
            obj_ = LimitType.factory()
            obj_.build(child_)
            self.limit = obj_
            obj_.original_tagname_ = 'limit'
        elif nodeName_ == 'safety_controller':
            obj_ = SafetyControllerType.factory()
            obj_.build(child_)
            self.safety_controller = obj_
            obj_.original_tagname_ = 'safety_controller'
        elif nodeName_ == 'mimic':
            obj_ = MimicType.factory()
            obj_.build(child_)
            self.mimic = obj_
            obj_.original_tagname_ = 'mimic'
# end class JointType


class ActuatorTransmissionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, hardwareInterface=None, mechanicalReduction=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.hardwareInterface = hardwareInterface
        self.mechanicalReduction = mechanicalReduction
    def factory(*args_, **kwargs_):
        if ActuatorTransmissionType.subclass:
            return ActuatorTransmissionType.subclass(*args_, **kwargs_)
        else:
            return ActuatorTransmissionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hardwareInterface(self): return self.hardwareInterface
    def set_hardwareInterface(self, hardwareInterface): self.hardwareInterface = hardwareInterface
    def get_mechanicalReduction(self): return self.mechanicalReduction
    def set_mechanicalReduction(self, mechanicalReduction): self.mechanicalReduction = mechanicalReduction
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            self.hardwareInterface is not None or
            self.mechanicalReduction is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ActuatorTransmissionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActuatorTransmissionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ActuatorTransmissionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ActuatorTransmissionType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ActuatorTransmissionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.hardwareInterface is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shardwareInterface>%s</%shardwareInterface>%s' % (namespace_, self.gds_format_string(quote_xml(self.hardwareInterface), input_name='hardwareInterface'), namespace_, eol_))
        if self.mechanicalReduction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smechanicalReduction>%s</%smechanicalReduction>%s' % (namespace_, self.gds_format_double(self.mechanicalReduction, input_name='mechanicalReduction'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ActuatorTransmissionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.hardwareInterface is not None:
            showIndent(outfile, level)
            outfile.write('hardwareInterface=%s,\n' % quote_python(self.hardwareInterface))
        if self.mechanicalReduction is not None:
            showIndent(outfile, level)
            outfile.write('mechanicalReduction=%e,\n' % self.mechanicalReduction)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'hardwareInterface':
            hardwareInterface_ = child_.text
            hardwareInterface_ = self.gds_validate_string(hardwareInterface_, node, 'hardwareInterface')
            self.hardwareInterface = hardwareInterface_
        elif nodeName_ == 'mechanicalReduction':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'mechanicalReduction')
            self.mechanicalReduction = fval_
# end class ActuatorTransmissionType


class JointTransmissionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, hardwareInterface=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.hardwareInterface = hardwareInterface
    def factory(*args_, **kwargs_):
        if JointTransmissionType.subclass:
            return JointTransmissionType.subclass(*args_, **kwargs_)
        else:
            return JointTransmissionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hardwareInterface(self): return self.hardwareInterface
    def set_hardwareInterface(self, hardwareInterface): self.hardwareInterface = hardwareInterface
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            self.hardwareInterface is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='JointTransmissionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='JointTransmissionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='JointTransmissionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='JointTransmissionType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='JointTransmissionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.hardwareInterface is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shardwareInterface>%s</%shardwareInterface>%s' % (namespace_, self.gds_format_string(quote_xml(self.hardwareInterface), input_name='hardwareInterface'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='JointTransmissionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.hardwareInterface is not None:
            showIndent(outfile, level)
            outfile.write('hardwareInterface=%s,\n' % quote_python(self.hardwareInterface))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'hardwareInterface':
            hardwareInterface_ = child_.text
            hardwareInterface_ = self.gds_validate_string(hardwareInterface_, node, 'hardwareInterface')
            self.hardwareInterface = hardwareInterface_
# end class JointTransmissionType


class TransmissionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, type_=None, actuator=None, joint=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.type_ = type_
        self.actuator = actuator
        self.joint = joint
    def factory(*args_, **kwargs_):
        if TransmissionType.subclass:
            return TransmissionType.subclass(*args_, **kwargs_)
        else:
            return TransmissionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_actuator(self): return self.actuator
    def set_actuator(self, actuator): self.actuator = actuator
    def get_joint(self): return self.joint
    def set_joint(self, joint): self.joint = joint
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.actuator is not None or
            self.joint is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TransmissionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TransmissionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TransmissionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TransmissionType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TransmissionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespace_, self.gds_format_string(quote_xml(self.type_), input_name='type'), namespace_, eol_))
        if self.actuator is not None:
            self.actuator.export(outfile, level, namespace_, name_='actuator', pretty_print=pretty_print)
        if self.joint is not None:
            self.joint.export(outfile, level, namespace_, name_='joint', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TransmissionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_=%s,\n' % quote_python(self.type_))
        if self.actuator is not None:
            showIndent(outfile, level)
            outfile.write('actuator=model_.ActuatorTransmissionType(\n')
            self.actuator.exportLiteral(outfile, level, name_='actuator')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.joint is not None:
            showIndent(outfile, level)
            outfile.write('joint=model_.JointTransmissionType(\n')
            self.joint.exportLiteral(outfile, level, name_='joint')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
        elif nodeName_ == 'actuator':
            obj_ = ActuatorTransmissionType.factory()
            obj_.build(child_)
            self.actuator = obj_
            obj_.original_tagname_ = 'actuator'
        elif nodeName_ == 'joint':
            obj_ = JointTransmissionType.factory()
            obj_.build(child_)
            self.joint = obj_
            obj_.original_tagname_ = 'joint'
# end class TransmissionType


class GazeboMaterialType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None):
        self.original_tagname_ = None
        self.value = _cast(None, value)
    def factory(*args_, **kwargs_):
        if GazeboMaterialType.subclass:
            return GazeboMaterialType.subclass(*args_, **kwargs_)
        else:
            return GazeboMaterialType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GazeboMaterialType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GazeboMaterialType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GazeboMaterialType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GazeboMaterialType'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GazeboMaterialType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='GazeboMaterialType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class GazeboMaterialType


class GazeboPluginType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, filename=None, robotNamespace=None, robotSimType=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.filename = _cast(None, filename)
        if robotNamespace is None:
            self.robotNamespace = []
        else:
            self.robotNamespace = robotNamespace
        if robotSimType is None:
            self.robotSimType = []
        else:
            self.robotSimType = robotSimType
    def factory(*args_, **kwargs_):
        if GazeboPluginType.subclass:
            return GazeboPluginType.subclass(*args_, **kwargs_)
        else:
            return GazeboPluginType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_robotNamespace(self): return self.robotNamespace
    def set_robotNamespace(self, robotNamespace): self.robotNamespace = robotNamespace
    def add_robotNamespace(self, value): self.robotNamespace.append(value)
    def insert_robotNamespace_at(self, index, value): self.robotNamespace.insert(index, value)
    def replace_robotNamespace_at(self, index, value): self.robotNamespace[index] = value
    def get_robotSimType(self): return self.robotSimType
    def set_robotSimType(self, robotSimType): self.robotSimType = robotSimType
    def add_robotSimType(self, value): self.robotSimType.append(value)
    def insert_robotSimType_at(self, index, value): self.robotSimType.insert(index, value)
    def replace_robotSimType_at(self, index, value): self.robotSimType[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_filename(self): return self.filename
    def set_filename(self, filename): self.filename = filename
    def hasContent_(self):
        if (
            self.robotNamespace or
            self.robotSimType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GazeboPluginType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GazeboPluginType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GazeboPluginType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GazeboPluginType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name), input_name='name'), ))
        if self.filename is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            outfile.write(' filename=%s' % (self.gds_format_string(quote_attrib(self.filename), input_name='filename'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GazeboPluginType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for robotNamespace_ in self.robotNamespace:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srobotNamespace>%s</%srobotNamespace>%s' % (namespace_, self.gds_format_string(quote_xml(robotNamespace_), input_name='robotNamespace'), namespace_, eol_))
        for robotSimType_ in self.robotSimType:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srobotSimType>%s</%srobotSimType>%s' % (namespace_, self.gds_format_string(quote_xml(robotSimType_), input_name='robotSimType'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='GazeboPluginType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.filename is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            showIndent(outfile, level)
            outfile.write('filename="%s",\n' % (self.filename,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('robotNamespace=[\n')
        level += 1
        for robotNamespace_ in self.robotNamespace:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(robotNamespace_))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('robotSimType=[\n')
        level += 1
        for robotSimType_ in self.robotSimType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(robotSimType_))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('filename', node)
        if value is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            self.filename = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'robotNamespace':
            robotNamespace_ = child_.text
            robotNamespace_ = self.gds_validate_string(robotNamespace_, node, 'robotNamespace')
            self.robotNamespace.append(robotNamespace_)
        elif nodeName_ == 'robotSimType':
            robotSimType_ = child_.text
            robotSimType_ = self.gds_validate_string(robotSimType_, node, 'robotSimType')
            self.robotSimType.append(robotSimType_)
# end class GazeboPluginType


class GazeboType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, reference=None, plugin=None, material=None, turnGravityOff=None, selfCollide=None):
        self.original_tagname_ = None
        self.reference = _cast(None, reference)
        self.plugin = plugin
        self.material = material
        self.turnGravityOff = turnGravityOff
        self.selfCollide = selfCollide
    def factory(*args_, **kwargs_):
        if GazeboType.subclass:
            return GazeboType.subclass(*args_, **kwargs_)
        else:
            return GazeboType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_plugin(self): return self.plugin
    def set_plugin(self, plugin): self.plugin = plugin
    def get_material(self): return self.material
    def set_material(self, material): self.material = material
    def get_turnGravityOff(self): return self.turnGravityOff
    def set_turnGravityOff(self, turnGravityOff): self.turnGravityOff = turnGravityOff
    def get_selfCollide(self): return self.selfCollide
    def set_selfCollide(self, selfCollide): self.selfCollide = selfCollide
    def get_reference(self): return self.reference
    def set_reference(self, reference): self.reference = reference
    def hasContent_(self):
        if (
            self.plugin is not None or
            self.material is not None or
            self.turnGravityOff is not None or
            self.selfCollide is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GazeboType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GazeboType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GazeboType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GazeboType'):
        if self.reference is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            outfile.write(' reference=%s' % (self.gds_format_string(quote_attrib(self.reference), input_name='reference'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GazeboType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.plugin is not None:
            self.plugin.export(outfile, level, namespace_, name_='plugin', pretty_print=pretty_print)
        if self.material is not None:
            self.material.export(outfile, level, namespace_, name_='material', pretty_print=pretty_print)
        if self.turnGravityOff is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sturnGravityOff>%s</%sturnGravityOff>%s' % (namespace_, self.gds_format_boolean(self.turnGravityOff, input_name='turnGravityOff'), namespace_, eol_))
        if self.selfCollide is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sselfCollide>%s</%sselfCollide>%s' % (namespace_, self.gds_format_boolean(self.selfCollide, input_name='selfCollide'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='GazeboType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.reference is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            showIndent(outfile, level)
            outfile.write('reference="%s",\n' % (self.reference,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.plugin is not None:
            showIndent(outfile, level)
            outfile.write('plugin=model_.GazeboPluginType(\n')
            self.plugin.exportLiteral(outfile, level, name_='plugin')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.material is not None:
            showIndent(outfile, level)
            outfile.write('material=model_.GazeboMaterialType(\n')
            self.material.exportLiteral(outfile, level, name_='material')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.turnGravityOff is not None:
            showIndent(outfile, level)
            outfile.write('turnGravityOff=%s,\n' % self.turnGravityOff)
        if self.selfCollide is not None:
            showIndent(outfile, level)
            outfile.write('selfCollide=%s,\n' % self.selfCollide)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('reference', node)
        if value is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            self.reference = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'plugin':
            obj_ = GazeboPluginType.factory()
            obj_.build(child_)
            self.plugin = obj_
            obj_.original_tagname_ = 'plugin'
        elif nodeName_ == 'material':
            obj_ = GazeboMaterialType.factory()
            obj_.build(child_)
            self.material = obj_
            obj_.original_tagname_ = 'material'
        elif nodeName_ == 'turnGravityOff':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'turnGravityOff')
            self.turnGravityOff = ival_
        elif nodeName_ == 'selfCollide':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'selfCollide')
            self.selfCollide = ival_
# end class GazeboType


class RobotType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, version='1.0', name=None, joint=None, link=None, transmission=None, gazebo=None, material=None):
        self.original_tagname_ = None
        self.version = _cast(None, version)
        self.name = _cast(None, name)
        if joint is None:
            self.joint = []
        else:
            self.joint = joint
        if link is None:
            self.link = []
        else:
            self.link = link
        if transmission is None:
            self.transmission = []
        else:
            self.transmission = transmission
        if gazebo is None:
            self.gazebo = []
        else:
            self.gazebo = gazebo
        if material is None:
            self.material = []
        else:
            self.material = material
    def factory(*args_, **kwargs_):
        if RobotType.subclass:
            return RobotType.subclass(*args_, **kwargs_)
        else:
            return RobotType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_joint(self): return self.joint
    def set_joint(self, joint): self.joint = joint
    def add_joint(self, value): self.joint.append(value)
    def insert_joint_at(self, index, value): self.joint.insert(index, value)
    def replace_joint_at(self, index, value): self.joint[index] = value
    def get_link(self): return self.link
    def set_link(self, link): self.link = link
    def add_link(self, value): self.link.append(value)
    def insert_link_at(self, index, value): self.link.insert(index, value)
    def replace_link_at(self, index, value): self.link[index] = value
    def get_transmission(self): return self.transmission
    def set_transmission(self, transmission): self.transmission = transmission
    def add_transmission(self, value): self.transmission.append(value)
    def insert_transmission_at(self, index, value): self.transmission.insert(index, value)
    def replace_transmission_at(self, index, value): self.transmission[index] = value
    def get_gazebo(self): return self.gazebo
    def set_gazebo(self, gazebo): self.gazebo = gazebo
    def add_gazebo(self, value): self.gazebo.append(value)
    def insert_gazebo_at(self, index, value): self.gazebo.insert(index, value)
    def replace_gazebo_at(self, index, value): self.gazebo[index] = value
    def get_material(self): return self.material
    def set_material(self, material): self.material = material
    def add_material(self, value): self.material.append(value)
    def insert_material_at(self, index, value): self.material.insert(index, value)
    def replace_material_at(self, index, value): self.material[index] = value
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            self.joint or
            self.link or
            self.transmission or
            self.gazebo or
            self.material
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RobotType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RobotType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RobotType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RobotType'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version), input_name='version'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RobotType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for joint_ in self.joint:
            joint_.export(outfile, level, namespace_, name_='joint', pretty_print=pretty_print)
        for link_ in self.link:
            link_.export(outfile, level, namespace_, name_='link', pretty_print=pretty_print)
        for transmission_ in self.transmission:
            transmission_.export(outfile, level, namespace_, name_='transmission', pretty_print=pretty_print)
        for gazebo_ in self.gazebo:
            gazebo_.export(outfile, level, namespace_, name_='gazebo', pretty_print=pretty_print)
        for material_ in self.material:
            material_.export(outfile, level, namespace_, name_='material', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RobotType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('joint=[\n')
        level += 1
        for joint_ in self.joint:
            showIndent(outfile, level)
            outfile.write('model_.JointType(\n')
            joint_.exportLiteral(outfile, level, name_='JointType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('link=[\n')
        level += 1
        for link_ in self.link:
            showIndent(outfile, level)
            outfile.write('model_.LinkType(\n')
            link_.exportLiteral(outfile, level, name_='LinkType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('transmission=[\n')
        level += 1
        for transmission_ in self.transmission:
            showIndent(outfile, level)
            outfile.write('model_.TransmissionType(\n')
            transmission_.exportLiteral(outfile, level, name_='TransmissionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('gazebo=[\n')
        level += 1
        for gazebo_ in self.gazebo:
            showIndent(outfile, level)
            outfile.write('model_.GazeboType(\n')
            gazebo_.exportLiteral(outfile, level, name_='GazeboType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('material=[\n')
        level += 1
        for material_ in self.material:
            showIndent(outfile, level)
            outfile.write('model_.MaterialType(\n')
            material_.exportLiteral(outfile, level, name_='MaterialType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'joint':
            obj_ = JointType.factory()
            obj_.build(child_)
            self.joint.append(obj_)
            obj_.original_tagname_ = 'joint'
        elif nodeName_ == 'link':
            obj_ = LinkType.factory()
            obj_.build(child_)
            self.link.append(obj_)
            obj_.original_tagname_ = 'link'
        elif nodeName_ == 'transmission':
            obj_ = TransmissionType.factory()
            obj_.build(child_)
            self.transmission.append(obj_)
            obj_.original_tagname_ = 'transmission'
        elif nodeName_ == 'gazebo':
            obj_ = GazeboType.factory()
            obj_.build(child_)
            self.gazebo.append(obj_)
            obj_.original_tagname_ = 'gazebo'
        elif nodeName_ == 'material':
            obj_ = MaterialType.factory()
            obj_.build(child_)
            self.material.append(obj_)
            obj_.original_tagname_ = 'material'
# end class RobotType


GDSClassesMapping = {
    'origin': PoseType,
    'cylinder': CylinderType,
    'verbose': VerboseType,
    'color': ColorType,
    'safety_controller': SafetyControllerType,
    'collision': CollisionType,
    'dynamics': DynamicsType,
    'axis': AxisType,
    'calibration': CalibrationType,
    'actuator': ActuatorTransmissionType,
    'texture': TextureType,
    'limit': LimitType,
    'gazebo': GazeboType,
    'parent': ParentType,
    'material': MaterialType,
    'joint': JointType,
    'visual': VisualType,
    'mesh': MeshType,
    'link': LinkType,
    'child': ChildType,
    'inertia': InertiaType,
    'box': BoxType,
    'contact_coefficients': ContactType,
    'sphere': SphereType,
    'geometry': GeometryType,
    'inertial': InertialType,
    'plugin': GazeboPluginType,
    'robot': RobotType,
    'transmission': TransmissionType,
    'mimic': MimicType,
    'mass': MassType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'PoseType'
        rootClass = PoseType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'PoseType'
        rootClass = PoseType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from io import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'PoseType'
        rootClass = PoseType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'PoseType'
        rootClass = PoseType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from urdf_dom import *\n\n')
        sys.stdout.write('import urdf_dom as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "ActuatorTransmissionType",
    "AxisType",
    "BoxType",
    "CalibrationType",
    "ChildType",
    "CollisionType",
    "ColorType",
    "ContactType",
    "CylinderType",
    "DynamicsType",
    "GazeboMaterialType",
    "GazeboPluginType",
    "GazeboType",
    "GeometryType",
    "InertiaType",
    "InertialType",
    "JointTransmissionType",
    "JointType",
    "LimitType",
    "LinkType",
    "MassType",
    "MaterialType",
    "MeshType",
    "MimicType",
    "ParentType",
    "PoseType",
    "RobotType",
    "SafetyControllerType",
    "SphereType",
    "TextureType",
    "TransmissionType",
    "VerboseType",
    "VisualType"
]
